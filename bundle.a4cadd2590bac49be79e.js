"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[996],{760:(t,e,n)=>{n.d(e,{$V:()=>s,EM:()=>l,L4:()=>a,Q_:()=>c,VQ:()=>d,dv:()=>o,ms:()=>r,wG:()=>u,xJ:()=>i});const o=0,s=1,r=2,i=2,a=1.25,c=1,u=32,l=65535,d=Math.pow(2,-24)},996:(t,e,n)=>{n.d(e,{r:()=>ut});var o=n(477),s=n(760);class r{constructor(){}}function i(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function a(t){let e=-1,n=-1/0;for(let o=0;o<3;o++){const s=t[o+3]-t[o];s>n&&(n=s,e=o)}return e}function c(t,e){e.set(t)}function u(t,e,n){let o,s;for(let r=0;r<3;r++){const i=r+3;o=t[r],s=e[r],n[r]=o<s?o:s,o=t[i],s=e[i],n[i]=o>s?o:s}}function l(t,e,n){for(let o=0;o<3;o++){const s=e[t+2*o],r=e[t+2*o+1],i=s-r,a=s+r;i<n[o]&&(n[o]=i),a>n[o+3]&&(n[o+3]=a)}}function d(t){const e=t[3]-t[0],n=t[4]-t[1],o=t[5]-t[2];return 2*(e*n+n*o+o*e)}function f(t,e,n,o,s=null){let r=1/0,i=1/0,a=1/0,c=-1/0,u=-1/0,l=-1/0,d=1/0,f=1/0,p=1/0,h=-1/0,y=-1/0,x=-1/0;const m=null!==s;for(let o=6*e,s=6*(e+n);o<s;o+=6){const e=t[o+0],n=t[o+1],s=e-n,w=e+n;s<r&&(r=s),w>c&&(c=w),m&&e<d&&(d=e),m&&e>h&&(h=e);const g=t[o+2],P=t[o+3],B=g-P,b=g+P;B<i&&(i=B),b>u&&(u=b),m&&g<f&&(f=g),m&&g>y&&(y=g);const T=t[o+4],A=t[o+5],M=T-A,v=T+A;M<a&&(a=M),v>l&&(l=v),m&&T<p&&(p=T),m&&T>x&&(x=T)}o[0]=r,o[1]=i,o[2]=a,o[3]=c,o[4]=u,o[5]=l,m&&(s[0]=d,s[1]=f,s[2]=p,s[3]=h,s[4]=y,s[5]=x)}const p=(t,e)=>t.candidate-e.candidate,h=new Array(32).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),y=new Float32Array(6);class x{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,o=-1/0;for(let s=0,r=t.length;s<r;s++){const r=t[s][e];n=r<n?r:n,o=r>o?r:o}this.min=n,this.max=o}setFromPoints(t,e){let n=1/0,o=-1/0;for(let s=0,r=e.length;s<r;s++){const r=e[s],i=t.dot(r);n=i<n?i:n,o=i>o?i:o}this.min=n,this.max=o}isSeparated(t){return this.min>t.max||t.min>this.max}}x.prototype.setFromBox=function(){const t=new o.Pa4;return function(e,n){const o=n.min,s=n.max;let r=1/0,i=-1/0;for(let n=0;n<=1;n++)for(let a=0;a<=1;a++)for(let c=0;c<=1;c++){t.x=o.x*n+s.x*(1-n),t.y=o.y*a+s.y*(1-a),t.z=o.z*c+s.z*(1-c);const u=e.dot(t);r=Math.min(u,r),i=Math.max(u,i)}this.min=r,this.max=i}}(),new x;const m=function(){const t=new o.Pa4,e=new o.Pa4,n=new o.Pa4;return function(o,s,r){const i=o.start,a=t,c=s.start,u=e;n.subVectors(i,c),t.subVectors(o.end,o.start),e.subVectors(s.end,s.start);const l=n.dot(u),d=u.dot(a),f=u.dot(u),p=n.dot(a),h=a.dot(a)*f-d*d;let y,x;y=0!==h?(l*d-p*f)/h:0,x=(l+y*d)/f,r.x=y,r.y=x}}(),w=function(){const t=new o.FM8,e=new o.Pa4,n=new o.Pa4;return function(o,s,r,i){m(o,s,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return o.at(a,r),void s.at(c,i);if(a>=0&&a<=1)return c<0?s.at(0,i):s.at(1,i),void o.closestPointToPoint(i,!0,r);if(c>=0&&c<=1)return a<0?o.at(0,r):o.at(1,r),void s.closestPointToPoint(r,!0,i);{let t,u;t=a<0?o.start:o.end,u=c<0?s.start:s.end;const l=e,d=n;return o.closestPointToPoint(u,!0,e),s.closestPointToPoint(t,!0,n),l.distanceToSquared(u)<=d.distanceToSquared(t)?(r.copy(l),void i.copy(u)):(r.copy(t),void i.copy(d))}}}(),g=function(){const t=new o.Pa4,e=new o.Pa4,n=new o.JOQ,s=new o.Zzh;return function(o,r){const{radius:i,center:a}=o,{a:c,b:u,c:l}=r;if(s.start=c,s.end=u,s.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;if(s.start=c,s.end=l,s.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;if(s.start=u,s.end=l,s.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;const d=r.getPlane(n);if(Math.abs(d.distanceToPoint(a))<=i){const t=d.projectPoint(a,e);if(r.containsPoint(t))return!0}return!1}}();function P(t){return Math.abs(t)<1e-15}class B extends o.CJI{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new o.Pa4)),this.satBounds=new Array(4).fill().map((()=>new x)),this.points=[this.a,this.b,this.c],this.sphere=new o.aLr,this.plane=new o.JOQ,this.needsUpdate=!0}intersectsSphere(t){return g(t,this)}update(){const t=this.a,e=this.b,n=this.c,o=this.points,s=this.satAxes,r=this.satBounds,i=s[0],a=r[0];this.getNormal(i),a.setFromPoints(i,o);const c=s[1],u=r[1];c.subVectors(t,e),u.setFromPoints(c,o);const l=s[2],d=r[2];l.subVectors(e,n),d.setFromPoints(l,o);const f=s[3],p=r[3];f.subVectors(n,t),p.setFromPoints(f,o),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(i,t),this.needsUpdate=!1}}B.prototype.closestPointToSegment=function(){const t=new o.Pa4,e=new o.Pa4,n=new o.Zzh;return function(o,s=null,r=null){const{start:i,end:a}=o,c=this.points;let u,l=1/0;for(let i=0;i<3;i++){const a=(i+1)%3;n.start.copy(c[i]),n.end.copy(c[a]),w(n,o,t,e),u=t.distanceToSquared(e),u<l&&(l=u,s&&s.copy(t),r&&r.copy(e))}return this.closestPointToPoint(i,t),u=i.distanceToSquared(t),u<l&&(l=u,s&&s.copy(t),r&&r.copy(i)),this.closestPointToPoint(a,t),u=a.distanceToSquared(t),u<l&&(l=u,s&&s.copy(t),r&&r.copy(a)),Math.sqrt(l)}}(),B.prototype.intersectsTriangle=function(){const t=new B,e=new Array(3),n=new Array(3),s=new x,r=new x,i=new o.Pa4,a=new o.Pa4,c=new o.Pa4,u=new o.Pa4,l=new o.Zzh,d=new o.Zzh,f=new o.Zzh;return function(o,p=null){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(t.copy(o),t.update(),o=t);const h=this.plane,y=o.plane;if(Math.abs(h.normal.dot(y.normal))>1-1e-10){const t=this.satBounds,a=this.satAxes;n[0]=o.a,n[1]=o.b,n[2]=o.c;for(let e=0;e<4;e++){const o=t[e],r=a[e];if(s.setFromPoints(r,n),o.isSeparated(s))return!1}const c=o.satBounds,u=o.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const n=c[t],o=u[t];if(s.setFromPoints(o,e),n.isSeparated(s))return!1}for(let t=0;t<4;t++){const o=a[t];for(let t=0;t<4;t++){const a=u[t];if(i.crossVectors(o,a),s.setFromPoints(i,e),r.setFromPoints(i,n),s.isSeparated(r))return!1}}return p&&(console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),p.start.set(0,0,0),p.end.set(0,0,0)),!0}{const t=this.points;let e=!1,n=0;for(let o=0;o<3;o++){const s=t[o],r=t[(o+1)%3];l.start.copy(s),l.end.copy(r),l.delta(a);const i=e?d.start:d.end,c=P(y.distanceToPoint(s));if(P(y.normal.dot(a))&&c){d.copy(l),n=2;break}if((y.intersectLine(l,i)||c)&&!P(i.distanceTo(r))){if(n++,e)break;e=!0}}if(1===n&&o.containsPoint(d.end))return p&&(p.start.copy(d.end),p.end.copy(d.end)),!0;if(2!==n)return!1;const s=o.points;let r=!1,i=0;for(let t=0;t<3;t++){const e=s[t],n=s[(t+1)%3];l.start.copy(e),l.end.copy(n),l.delta(c);const o=r?f.start:f.end,a=P(h.distanceToPoint(e));if(P(h.normal.dot(c))&&a){f.copy(l),i=2;break}if((h.intersectLine(l,o)||a)&&!P(o.distanceTo(n))){if(i++,r)break;r=!0}}if(1===i&&this.containsPoint(f.end))return p&&(p.start.copy(f.end),p.end.copy(f.end)),!0;if(2!==i)return!1;if(d.delta(a),f.delta(c),a.dot(c)<0){let t=f.start;f.start=f.end,f.end=t}const x=d.start.dot(a),m=d.end.dot(a),w=f.start.dot(a),g=f.end.dot(a),B=m<w,b=x<g;return(x===g||w===m||B!==b)&&(p&&(u.subVectors(d.start,f.start),u.dot(a)>0?p.start.copy(d.start):p.start.copy(f.start),u.subVectors(d.end,f.end),u.dot(a)<0?p.end.copy(d.end):p.end.copy(f.end)),!0)}}}(),B.prototype.distanceToPoint=function(){const t=new o.Pa4;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),B.prototype.distanceToTriangle=function(){const t=new o.Pa4,e=new o.Pa4,n=["a","b","c"],s=new o.Zzh,r=new o.Zzh;return function(o,i=null,a=null){const c=i||a?s:null;if(this.intersectsTriangle(o,c))return(i||a)&&(i&&c.getCenter(i),a&&c.getCenter(a)),0;let u=1/0;for(let e=0;e<3;e++){let s;const r=n[e],c=o[r];this.closestPointToPoint(c,t),s=c.distanceToSquared(t),s<u&&(u=s,i&&i.copy(t),a&&a.copy(c));const l=this[r];o.closestPointToPoint(l,t),s=l.distanceToSquared(t),s<u&&(u=s,i&&i.copy(l),a&&a.copy(t))}for(let c=0;c<3;c++){const l=n[c],d=n[(c+1)%3];s.set(this[l],this[d]);for(let c=0;c<3;c++){const l=n[c],d=n[(c+1)%3];r.set(o[l],o[d]),w(s,r,t,e);const f=t.distanceToSquared(e);f<u&&(u=f,i&&i.copy(t),a&&a.copy(e))}}return Math.sqrt(u)}}();class b{constructor(t,e,n){this.isOrientedBox=!0,this.min=new o.Pa4,this.max=new o.Pa4,this.matrix=new o.yGw,this.invMatrix=new o.yGw,this.points=new Array(8).fill().map((()=>new o.Pa4)),this.satAxes=new Array(3).fill().map((()=>new o.Pa4)),this.satBounds=new Array(3).fill().map((()=>new x)),this.alignedSatBounds=new Array(3).fill().map((()=>new x)),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}b.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,o=this.points;for(let s=0;s<=1;s++)for(let r=0;r<=1;r++)for(let i=0;i<=1;i++){const a=o[1*s|2*r|4*i];a.x=s?n.x:e.x,a.y=r?n.y:e.y,a.z=i?n.z:e.z,a.applyMatrix4(t)}const s=this.satBounds,r=this.satAxes,i=o[0];for(let t=0;t<3;t++){const e=r[t],n=s[t],a=o[1<<t];e.subVectors(i,a),n.setFromPoints(e,o)}const a=this.alignedSatBounds;a[0].setFromPointsField(o,"x"),a[1].setFromPointsField(o,"y"),a[2].setFromPointsField(o,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},b.prototype.intersectsBox=function(){const t=new x;return function(e){this.needsUpdate&&this.update();const n=e.min,o=e.max,s=this.satBounds,r=this.satAxes,i=this.alignedSatBounds;if(t.min=n.x,t.max=o.x,i[0].isSeparated(t))return!1;if(t.min=n.y,t.max=o.y,i[1].isSeparated(t))return!1;if(t.min=n.z,t.max=o.z,i[2].isSeparated(t))return!1;for(let n=0;n<3;n++){const o=r[n],i=s[n];if(t.setFromBox(o,e),i.isSeparated(t))return!1}return!0}}(),b.prototype.intersectsTriangle=function(){const t=new B,e=new Array(3),n=new x,s=new x,r=new o.Pa4;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(t.copy(o),t.update(),o=t);const i=this.satBounds,a=this.satAxes;e[0]=o.a,e[1]=o.b,e[2]=o.c;for(let t=0;t<3;t++){const o=i[t],s=a[t];if(n.setFromPoints(s,e),o.isSeparated(n))return!1}const c=o.satBounds,u=o.satAxes,l=this.points;for(let t=0;t<3;t++){const e=c[t],o=u[t];if(n.setFromPoints(o,l),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const o=a[t];for(let t=0;t<4;t++){const i=u[t];if(r.crossVectors(o,i),n.setFromPoints(r,e),s.setFromPoints(r,l),n.isSeparated(s))return!1}}return!0}}(),b.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},b.prototype.distanceToPoint=function(){const t=new o.Pa4;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),b.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new o.Zzh)),n=new Array(12).fill().map((()=>new o.Zzh)),s=new o.Pa4,r=new o.Pa4;return function(o,i=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(a||c)&&(o.getCenter(r),this.closestPointToPoint(r,s),o.closestPointToPoint(s,r),a&&a.copy(s),c&&c.copy(r)),0;const u=i*i,l=o.min,d=o.max,f=this.points;let p=1/0;for(let t=0;t<8;t++){const e=f[t];r.copy(e).clamp(l,d);const n=e.distanceToSquared(r);if(n<p&&(p=n,a&&a.copy(e),c&&c.copy(r),n<u))return Math.sqrt(n)}let h=0;for(let o=0;o<3;o++)for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){const i=(o+1)%3,a=(o+2)%3,c=1<<o|s<<i|r<<a,u=f[s<<i|r<<a],p=f[c];e[h].set(u,p);const y=t[o],x=t[i],m=t[a],w=n[h],g=w.start,P=w.end;g[y]=l[y],g[x]=s?l[x]:d[x],g[m]=r?l[m]:d[x],P[y]=d[y],P[x]=s?l[x]:d[x],P[m]=r?l[m]:d[x],h++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){r.x=t?d.x:l.x,r.y=e?d.y:l.y,r.z=n?d.z:l.z,this.closestPointToPoint(r,s);const o=r.distanceToSquared(s);if(o<p&&(p=o,a&&a.copy(s),c&&c.copy(r),o<u))return Math.sqrt(o)}for(let t=0;t<12;t++){const o=e[t];for(let t=0;t<12;t++){const e=n[t];w(o,e,s,r);const i=s.distanceToSquared(r);if(i<p&&(p=i,a&&a.copy(s),c&&c.copy(r),i<u))return Math.sqrt(i)}}return Math.sqrt(p)}}();const T=new o.Pa4,A=new o.Pa4,M=new o.Pa4,v=new o.FM8,F=new o.FM8,S=new o.FM8,z=new o.Pa4;function U(t,e,n,s,r){const i=3*s,a=t.index.getX(i),c=t.index.getX(i+1),u=t.index.getX(i+2),l=function(t,e,n,s,r,i,a){T.fromBufferAttribute(e,s),A.fromBufferAttribute(e,r),M.fromBufferAttribute(e,i);const c=function(t,e,n,s,r,i){let a;return a=i===o._Li?t.intersectTriangle(s,n,e,!0,r):t.intersectTriangle(e,n,s,i!==o.ehD,r),null===a?null:{distance:t.origin.distanceTo(r),point:r.clone()}}(t,T,A,M,z,a);if(c){n&&(v.fromBufferAttribute(n,s),F.fromBufferAttribute(n,r),S.fromBufferAttribute(n,i),c.uv=o.CJI.getUV(z,T,A,M,v,F,S,new o.FM8));const t={a:s,b:r,c:i,normal:new o.Pa4,materialIndex:0};o.CJI.getNormal(T,A,M,t.normal),c.face=t,c.faceIndex=s}return c}(n,t.attributes.position,t.attributes.uv,a,c,u,e);return l?(l.faceIndex=s,r&&r.push(l),l):null}function V(t,e,n,o){const s=t.a,r=t.b,i=t.c;let a=e,c=e+1,u=e+2;n&&(a=n.getX(e),c=n.getX(e+1),u=n.getX(e+2)),s.x=o.getX(a),s.y=o.getY(a),s.z=o.getZ(a),r.x=o.getX(c),r.y=o.getY(c),r.z=o.getZ(c),i.x=o.getX(u),i.y=o.getY(u),i.z=o.getZ(u)}function I(t,e,n,o,s,r,i){const a=n.index,c=n.attributes.position;for(let n=t,u=e+t;n<u;n++)if(V(i,3*n,a,c),i.needsUpdate=!0,o(i,n,s,r))return!0;return!1}class C{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}var q=n(886);const Z=new o.ZzF,_=new o.Pa4,k=["x","y","z"];function E(t,e,n,o,s){let r=2*t,i=O,a=Q,c=R;if((0,q.ee)(r,a))!function(t,e,n,o,s,r){for(let i=o,a=o+s;i<a;i++)U(t,e,n,i,r)}(e,n,o,(0,q.ew)(t,c),(0,q.ai)(r,a),s);else{const r=(0,q.lB)(t);L(r,i,o,_)&&E(r,e,n,o,s);const a=(0,q.J8)(t,c);L(a,i,o,_)&&E(a,e,n,o,s)}}function G(t,e,n,o){let s=2*t,r=O,i=Q,a=R;if((0,q.ee)(s,i))return function(t,e,n,o,s){let r=1/0,i=null;for(let a=o,c=o+s;a<c;a++){const o=U(t,e,n,a);o&&o.distance<r&&(i=o,r=o.distance)}return i}(e,n,o,(0,q.ew)(t,a),(0,q.ai)(s,i));{const s=(0,q.ki)(t,a),i=k[s],c=o.direction[i]>=0;let u,l;c?(u=(0,q.lB)(t),l=(0,q.J8)(t,a)):(u=(0,q.J8)(t,a),l=(0,q.lB)(t));const d=L(u,r,o,_)?G(u,e,n,o):null;if(d){const t=d.point[i];if(c?t<=r[l+s]:t>=r[l+s+3])return d}const f=L(l,r,o,_)?G(l,e,n,o):null;return d&&f?d.distance<=f.distance?d:f:d||f||null}}const J=function(){let t,e;const n=[],r=new C((()=>new o.ZzF));return function(...o){t=r.getPrimitive(),e=r.getPrimitive(),n.push(t,e);const s=a(...o);r.releasePrimitive(t),r.releasePrimitive(e),n.pop(),n.pop();const i=n.length;return i>0&&(e=n[i-1],t=n[i-2]),s};function a(n,o,r,c,u=null,l=0,d=0){function f(t){let e=2*t,n=Q,o=R;for(;!(0,q.ee)(e,n);)e=2*(t=(0,q.lB)(t));return(0,q.ew)(t,o)}function p(t){let e=2*t,n=Q,o=R;for(;!(0,q.ee)(e,n);)e=2*(t=(0,q.J8)(t,o));return(0,q.ew)(t,o)+(0,q.ai)(e,n)}let h=2*n,y=O,x=Q,m=R;if((0,q.ee)(h,x)){const e=(0,q.ew)(n,m),o=(0,q.ai)(h,x);return i((0,q.V4)(n),y,t),c(e,o,!1,d,l+n,t)}{const h=(0,q.lB)(n),w=(0,q.J8)(n,m);let g,P,B,b,T=h,A=w;if(u&&(B=t,b=e,i((0,q.V4)(T),y,B),i((0,q.V4)(A),y,b),g=u(B),P=u(b),P<g)){T=w,A=h;const t=g;g=P,P=t,B=b}B||(B=t,i((0,q.V4)(T),y,B));const M=r(B,(0,q.ee)(2*T,x),g,d+1,l+T);let v;if(M===s.xJ){const t=f(T);v=c(t,p(T)-t,!0,d+1,l+T,B)}else v=M&&a(T,o,r,c,u,l,d+1);if(v)return!0;b=e,i((0,q.V4)(A),y,b);const F=r(b,(0,q.ee)(2*A,x),P,d+1,l+A);let S;if(F===s.xJ){const t=f(A);S=c(t,p(A)-t,!0,d+1,l+A,b)}else S=F&&a(A,o,r,c,u,l,d+1);return!!S}}}(),D=function(){const t=new B,e=new B,n=new o.yGw,s=new b,r=new b;return function o(a,c,u,l,d=null){let f=2*a,p=O,h=Q,y=R;if(null===d&&(u.boundingBox||u.computeBoundingBox(),s.set(u.boundingBox.min,u.boundingBox.max,l),d=s),!(0,q.ee)(f,h)){const t=a+8,e=y[a+6];return i((0,q.V4)(t),p,Z),d.intersectsBox(Z)&&o(t,c,u,l,d)?!0:(i((0,q.V4)(e),p,Z),!(!d.intersectsBox(Z)||!o(e,c,u,l,d)))}{const o=c,s=o.index,d=o.attributes.position,x=u.index,m=u.attributes.position,w=(0,q.ew)(a,y),g=(0,q.ai)(f,h);if(n.copy(l).invert(),u.boundsTree)return i((0,q.V4)(a),p,r),r.matrix.copy(n),r.needsUpdate=!0,u.boundsTree.shapecast({intersectsBounds:t=>r.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(l),t.b.applyMatrix4(l),t.c.applyMatrix4(l),t.needsUpdate=!0;for(let n=3*w,o=3*(g+w);n<o;n+=3)if(V(e,n,s,d),e.needsUpdate=!0,t.intersectsTriangle(e))return!0;return!1}});for(let o=3*w,r=g+3*w;o<r;o+=3){V(t,o,s,d),t.a.applyMatrix4(n),t.b.applyMatrix4(n),t.c.applyMatrix4(n),t.needsUpdate=!0;for(let n=0,o=x.count;n<o;n+=3)if(V(e,n,x,m),e.needsUpdate=!0,t.intersectsTriangle(e))return!0}}}}();function L(t,e,n,o){return i(t,e,Z),n.intersectBox(Z,o)}const X=[];let H,O,Q,R;function N(t){H&&X.push(H),H=t,O=new Float32Array(t),Q=new Uint16Array(t),R=new Uint32Array(t)}function Y(){H=null,O=null,Q=null,R=null,X.length&&N(X.pop())}const $=Symbol("skip tree generation"),j=new o.ZzF,W=new o.ZzF,K=new o.yGw,tt=new b,et=new b,nt=new o.Pa4,ot=new o.Pa4,st=new o.Pa4,rt=new o.Pa4,it=new o.Pa4,at=new o.ZzF,ct=new C((()=>new B));class ut{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),ut.serialize(arguments[0],{cloneBuffers:void 0===arguments[2]||arguments[2]});e={cloneBuffers:!0,...e};const n=t.geometry,o=t._roots,s=n.getIndex();let r;return r=e.cloneBuffers?{roots:o.map((t=>t.slice())),index:s.array.slice()}:{roots:o,index:s.array},r}static deserialize(t,e,n={}){if("boolean"==typeof n)return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),ut.deserialize(arguments[0],arguments[1],{setIndex:void 0===arguments[2]||arguments[2]});n={setIndex:!0,...n};const{index:s,roots:r}=t,i=new ut(e,{...n,[$]:!0});if(i._roots=r,n.setIndex){const n=e.getIndex();if(null===n){const n=new o.TlE(t.index,1,!1);e.setIndex(n)}else n.array!==s&&(n.array.set(s),n.needsUpdate=!0)}return i}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({strategy:s.dv,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[$]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[$]||(this._roots=function(t,e){const n=function(t,e){function n(t){A&&A(t/M)}function i(e,o,x,A=null,M=0){if(!v&&M>=P&&(v=!0,B&&(console.warn(`MeshBVH: Max depth of ${P} reached when generating BVH. Consider increasing maxDepth.`),console.warn(t))),x<=b||M>=P)return n(o+x),e.offset=o,e.count=x,e;const F=function(t,e,n,o,r,i){let f=-1,x=0;if(i===s.dv)f=a(e),-1!==f&&(x=(e[f]+e[f+3])/2);else if(i===s.$V)f=a(t),-1!==f&&(x=function(t,e,n,o){let s=0;for(let r=e,i=e+n;r<i;r++)s+=t[6*r+2*o];return s/n}(n,o,r,f));else if(i===s.ms){const i=d(t);let a=s.L4*r;const m=6*o,w=6*(o+r);for(let t=0;t<3;t++){const o=e[t],g=(e[t+3]-o)/32;if(r<8){const e=[...h];e.length=r;let o=0;for(let s=m;s<w;s+=6,o++){const r=e[o];r.candidate=n[s+2*t],r.count=0;const{bounds:i,leftCacheBounds:a,rightCacheBounds:c}=r;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,i[t]=1/0,i[t+3]=-1/0;l(s,n,i)}e.sort(p);let c=r;for(let t=0;t<c;t++){const n=e[t];for(;t+1<c&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),c--}for(let o=m;o<w;o+=6){const s=n[o+2*t];for(let t=0;t<c;t++){const r=e[t];s>=r.candidate?l(o,n,r.rightCacheBounds):(l(o,n,r.leftCacheBounds),r.count++)}}for(let n=0;n<c;n++){const o=e[n],c=o.count,u=r-o.count,l=o.leftCacheBounds,p=o.rightCacheBounds;let h=0;0!==c&&(h=d(l)/i);let y=0;0!==u&&(y=d(p)/i);const m=s.Q_+s.L4*(h*c+y*u);m<a&&(f=t,a=m,x=o.candidate)}}else{for(let t=0;t<32;t++){const e=h[t];e.count=0,e.candidate=o+g+t*g;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let e=m;e<w;e+=6){let s=~~((n[e+2*t]-o)/g);s>=32&&(s=31);const r=h[s];r.count++,l(e,n,r.bounds)}const e=h[31];c(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=h[t],n=h[t+1];u(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let p=0;for(let e=0;e<31;e++){const n=h[e],o=n.count,l=n.bounds,m=h[e+1].rightCacheBounds;0!==o&&(0===p?c(l,y):u(l,y,y)),p+=o;let w=0,g=0;0!==p&&(w=d(y)/i);const P=r-p;0!==P&&(g=d(m)/i);const B=s.Q_+s.L4*(w*p+g*P);B<a&&(f=t,a=B,x=n.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${i} used.`);return{axis:f,pos:x}}(e.boundingData,A,w,o,x,T);if(-1===F.axis)return n(o+x),e.offset=o,e.count=x,e;const S=function(t,e,n,o,s){let r=n,i=n+o-1;const a=s.pos,c=2*s.axis;for(;;){for(;r<=i&&e[6*r+c]<a;)r++;for(;r<=i&&e[6*i+c]>=a;)i--;if(!(r<i))return r;for(let n=0;n<3;n++){let o=t[3*r+n];t[3*r+n]=t[3*i+n],t[3*i+n]=o;let s=e[6*r+2*n+0];e[6*r+2*n+0]=e[6*i+2*n+0],e[6*i+2*n+0]=s;let a=e[6*r+2*n+1];e[6*r+2*n+1]=e[6*i+2*n+1],e[6*i+2*n+1]=a}r++,i--}}(g,w,o,x,F);if(S===o||S===o+x)n(o+x),e.offset=o,e.count=x;else{e.splitAxis=F.axis;const t=new r,n=o,s=S-o;e.left=t,t.boundingData=new Float32Array(6),f(w,n,s,t.boundingData,m),i(t,n,s,m,M+1);const a=new r,c=S,u=x-s;e.right=a,a.boundingData=new Float32Array(6),f(w,c,u,a.boundingData,m),i(a,c,u,m,M+1)}return e}!function(t,e){if(!t.index){const n=t.attributes.position.count,s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let r;r=n>65535?new Uint32Array(new s(4*n)):new Uint16Array(new s(2*n)),t.setIndex(new o.TlE(r,1));for(let t=0;t<n;t++)r[t]=t}}(t,e);const x=new Float32Array(6),m=new Float32Array(6),w=function(t,e){const n=t.attributes.position,o=t.index.array,r=o.length/3,i=new Float32Array(6*r),a=n.normalized,c=n.array,u=n.offset||0;let l=3;n.isInterleavedBufferAttribute&&(l=n.data.stride);const d=["getX","getY","getZ"];for(let t=0;t<r;t++){const r=3*t,f=6*t;let p,h,y;a?(p=o[r+0],h=o[r+1],y=o[r+2]):(p=o[r+0]*l+u,h=o[r+1]*l+u,y=o[r+2]*l+u);for(let t=0;t<3;t++){let o,r,u;a?(o=n[d[t]](p),r=n[d[t]](h),u=n[d[t]](y)):(o=c[p+t],r=c[h+t],u=c[y+t]);let l=o;r<l&&(l=r),u<l&&(l=u);let x=o;r>x&&(x=r),u>x&&(x=u);const m=(x-l)/2,w=2*t;i[f+w+0]=l+m,i[f+w+1]=m+(Math.abs(l)+m)*s.VQ,l<e[t]&&(e[t]=l),x>e[t+3]&&(e[t+3]=x)}}return i}(t,x),g=t.index.array,P=e.maxDepth,B=e.verbose,b=e.maxLeafTris,T=e.strategy,A=e.onProgress,M=t.index.count/3;let v=!1;const F=[],S=function(t){if(!t.groups||!t.groups.length)return[{offset:0,count:t.index.count/3}];const e=[],n=new Set;for(const e of t.groups)n.add(e.start),n.add(e.start+e.count);const o=Array.from(n.values()).sort(((t,e)=>t-e));for(let t=0;t<o.length-1;t++){const n=o[t],s=o[t+1];e.push({offset:n/3,count:(s-n)/3})}return e}(t);if(1===S.length){const t=S[0],e=new r;e.boundingData=x,function(t,e,n,o){let s=1/0,r=1/0,i=1/0,a=-1/0,c=-1/0,u=-1/0;for(let o=6*e,l=6*(e+n);o<l;o+=6){const e=t[o+0];e<s&&(s=e),e>a&&(a=e);const n=t[o+2];n<r&&(r=n),n>c&&(c=n);const l=t[o+4];l<i&&(i=l),l>u&&(u=l)}o[0]=s,o[1]=r,o[2]=i,o[3]=a,o[4]=c,o[5]=u}(w,t.offset,t.count,m),i(e,t.offset,t.count,m),F.push(e)}else for(let t of S){const e=new r;e.boundingData=new Float32Array(6),f(w,t.offset,t.count,e.boundingData,m),i(e,t.offset,t.count,m),F.push(e)}return F}(t,e);let i,x,m;const w=[],g=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let t=0;t<n.length;t++){const e=n[t];let o=P(e);const r=new g(s.wG*o);i=new Float32Array(r),x=new Uint32Array(r),m=new Uint16Array(r),B(0,e),w.push(r)}return w;function P(t){return t.count?1:1+P(t.left)+P(t.right)}function B(t,e){const n=t/4,o=t/2,r=!!e.count,a=e.boundingData;for(let t=0;t<6;t++)i[n+t]=a[t];if(r){const r=e.offset,i=e.count;return x[n+6]=r,m[o+14]=i,m[o+15]=s.EM,t+s.wG}{const o=e.left,r=e.right,i=e.splitAxis;let a;if(a=B(t+s.wG,o),a/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return x[n+6]=a/4,a=B(a,r),x[n+7]=i,a}}}(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new o.ZzF))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,n=e.index.array,o=e.attributes.position;let r,i,a,c,u=0;const l=this._roots;for(let t=0,e=l.length;t<e;t++)r=l[t],i=new Uint32Array(r),a=new Uint16Array(r),c=new Float32Array(r),d(0,u),u+=r.byteLength;function d(e,r,u=!1){const l=2*e;if(a[l+15]===s.EM){const t=i[e+6];let s=1/0,r=1/0,u=1/0,d=-1/0,f=-1/0,p=-1/0;for(let e=3*t,i=3*(t+a[l+14]);e<i;e++){const t=n[e],i=o.getX(t),a=o.getY(t),c=o.getZ(t);i<s&&(s=i),i>d&&(d=i),a<r&&(r=a),a>f&&(f=a),c<u&&(u=c),c>p&&(p=c)}return(c[e+0]!==s||c[e+1]!==r||c[e+2]!==u||c[e+3]!==d||c[e+4]!==f||c[e+5]!==p)&&(c[e+0]=s,c[e+1]=r,c[e+2]=u,c[e+3]=d,c[e+4]=f,c[e+5]=p,!0)}{const n=e+8,o=i[e+6],s=n+r,a=o+r;let l=u,f=!1,p=!1;t?l||(f=t.has(s),p=t.has(a),l=!f&&!p):(f=!0,p=!0);const h=l||p;let y=!1;(l||f)&&(y=d(n,r,l));let x=!1;h&&(x=d(o,r,l));const m=y||x;if(m)for(let t=0;t<3;t++){const s=n+t,r=o+t,i=c[s],a=c[s+3],u=c[r],l=c[r+3];c[e+t]=i<u?i:u,c[e+t+3]=a>l?a:l}return m}}}traverse(t,e=0){const n=this._roots[e],o=new Uint32Array(n),r=new Uint16Array(n);!function e(i,a=0){const c=2*i,u=r[c+15]===s.EM;if(u){const e=o[i+6],s=r[c+14];t(a,u,new Float32Array(n,4*i,6),e,s)}else{const r=i+s.wG/4,c=o[i+6],l=o[i+7];t(a,u,new Float32Array(n,4*i,6),l)||(e(r,a+1),e(c,a+1))}}(0)}raycast(t,e=o.Wl3){const n=this._roots,s=this.geometry,r=[],i=e.isMaterial,a=Array.isArray(e),c=s.groups,u=i?e.side:e;for(let o=0,i=n.length;o<i;o++){const i=a?e[c[o].materialIndex].side:u,l=r.length;if(N(n[o]),E(0,s,i,t,r),Y(),a){const t=c[o].materialIndex;for(let e=l,n=r.length;e<n;e++)r[e].face.materialIndex=t}}return r}raycastFirst(t,e=o.Wl3){const n=this._roots,s=this.geometry,r=e.isMaterial,i=Array.isArray(e);let a=null;const c=s.groups,u=r?e.side:e;for(let o=0,r=n.length;o<r;o++){const r=i?e[c[o].materialIndex].side:u;N(n[o]);const l=G(0,s,r,t);Y(),null!=l&&(null==a||l.distance<a.distance)&&(a=l,i&&(l.face.materialIndex=c[o].materialIndex))}return a}intersectsGeometry(t,e){const n=this.geometry;let o=!1;for(const s of this._roots)if(N(s),o=D(0,n,t,e),Y(),o)break;return o}shapecast(t,e,n){const o=this.geometry;if(t instanceof Function){if(e){const t=e;e=(e,n,o,s)=>{const r=3*n;return t(e,r,r+1,r+2,o,s)}}t={boundsTraverseOrder:n,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const s=ct.getPrimitive();let{boundsTraverseOrder:r,intersectsBounds:i,intersectsRange:a,intersectsTriangle:c}=t;if(a&&c){const t=a;a=(e,n,r,i,a)=>!!t(e,n,r,i,a)||I(e,n,o,c,r,i,s)}else a||(a=c?(t,e,n,r)=>I(t,e,o,c,n,r,s):(t,e,n)=>n);let u=!1,l=0;for(const t of this._roots){if(N(t),u=J(0,o,i,a,r,l),Y(),u)break;l+=t.byteLength}return ct.releasePrimitive(s),u}bvhcast(t,e,n){let{intersectsRanges:o,intersectsTriangles:s}=n;const r=this.geometry.index,i=this.geometry.attributes.position,a=t.geometry.index,c=t.geometry.attributes.position;K.copy(e).invert();const u=ct.getPrimitive(),l=ct.getPrimitive();if(s){function f(t,n,o,d,f,p,h,y){for(let x=o,m=o+d;x<m;x++){V(l,3*x,a,c),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let e=t,o=t+n;e<o;e++)if(V(u,3*e,r,i),u.needsUpdate=!0,s(u,l,e,x,f,p,h,y))return!0}return!1}if(o){const p=o;o=function(t,e,n,o,s,r,i,a){return!!p(t,e,n,o,s,r,i,a)||f(t,e,n,o,s,r,i,a)}}else o=f}t.getBoundingBox(W),W.applyMatrix4(e);const d=this.shapecast({intersectsBounds:t=>W.intersectsBox(t),intersectsRange:(e,n,s,r,i,a)=>(j.copy(a),j.applyMatrix4(K),t.shapecast({intersectsBounds:t=>j.intersectsBox(t),intersectsRange:(t,s,a,c,u)=>o(e,n,t,s,r,i,c,u)}))});return ct.releasePrimitive(u),ct.releasePrimitive(l),d}intersectsBox(t,e){return tt.set(t.min,t.max,e),tt.needsUpdate=!0,this.shapecast({intersectsBounds:t=>tt.intersectsBox(t),intersectsTriangle:t=>tt.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},o={},s=0,r=1/0){t.boundingBox||t.computeBoundingBox(),tt.set(t.boundingBox.min,t.boundingBox.max,e),tt.needsUpdate=!0;const i=this.geometry,a=i.attributes.position,c=i.index,u=t.attributes.position,l=t.index,d=ct.getPrimitive(),f=ct.getPrimitive();let p=ot,h=st,y=null,x=null;o&&(y=rt,x=it);let m=1/0,w=null,g=null;return K.copy(e).invert(),et.matrix.copy(K),this.shapecast({boundsTraverseOrder:t=>tt.distanceToBox(t),intersectsBounds:(t,e,n)=>n<m&&n<r&&(e&&(et.min.copy(t.min),et.max.copy(t.max),et.needsUpdate=!0),!0),intersectsRange:(n,o)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:t=>et.distanceToBox(t),intersectsBounds:(t,e,n)=>n<m&&n<r,intersectsRange:(t,r)=>{for(let i=3*t,P=3*(t+r);i<P;i+=3){V(f,i,l,u),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let t=3*n,e=3*(n+o);t<e;t+=3){V(d,t,c,a),d.needsUpdate=!0;const e=d.distanceToTriangle(f,p,y);if(e<m&&(h.copy(p),x&&x.copy(y),m=e,w=t/3,g=i/3),e<s)return!0}}}});for(let t=0,r=l?l.count:u.count;t<r;t+=3){V(f,t,l,u),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let e=3*n,r=3*(n+o);e<r;e+=3){V(d,e,c,a),d.needsUpdate=!0;const n=d.distanceToTriangle(f,p,y);if(n<m&&(h.copy(p),x&&x.copy(y),m=n,w=e/3,g=t/3),n<s)return!0}}}}),ct.releasePrimitive(d),ct.releasePrimitive(f),m===1/0?null:(n.point?n.point.copy(h):n.point=h.clone(),n.distance=m,n.faceIndex=w,o&&(o.point?o.point.copy(x):o.point=x.clone(),o.point.applyMatrix4(K),h.applyMatrix4(K),o.distance=h.sub(o.point).length(),o.faceIndex=g),n)}closestPointToPoint(t,e={},n=0,o=1/0){const s=n*n,r=o*o;let i=1/0,a=null;if(this.shapecast({boundsTraverseOrder:e=>(nt.copy(t).clamp(e.min,e.max),nt.distanceToSquared(t)),intersectsBounds:(t,e,n)=>n<i&&n<r,intersectsTriangle:(e,n)=>{e.closestPointToPoint(t,nt);const o=t.distanceToSquared(nt);return o<i&&(ot.copy(nt),i=o,a=n),o<s}}),i===1/0)return null;const c=Math.sqrt(i);return e.point?e.point.copy(ot):e.point=ot.clone(),e.distance=c,e.faceIndex=a,e}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach((e=>{i(0,new Float32Array(e),at),t.union(at)})),t}}},886:(t,e,n)=>{function o(t,e){return 65535===e[t+15]}function s(t,e){return e[t+6]}function r(t,e){return e[t+14]}function i(t){return t+8}function a(t,e){return e[t+6]}function c(t,e){return e[t+7]}function u(t){return t}n.d(e,{J8:()=>a,V4:()=>u,ai:()=>r,ee:()=>o,ew:()=>s,ki:()=>c,lB:()=>i})}}]);
//# sourceMappingURL=bundle.a4cadd2590bac49be79e.js.map