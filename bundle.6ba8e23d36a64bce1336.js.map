{"version":3,"file":"bundle.6ba8e23d36a64bce1336.js","mappings":"uBAAIA,E,wHCKG,MAAMC,UAA4BC,EAAAA,IAExCC,YAAaC,GAEZC,MAAO,CAENC,SAAU,CAETC,OAAQ,CAAEC,MAAO,IAAIC,EAAAA,KACrBC,OAAQ,CAAEF,MAAO,GACjBG,IAAK,CAAEH,MAAO,IAAII,EAAAA,IAInBC,aAAyB,4LAazBC,eAA2B,2FAKvBC,EAAAA,eACAC,EAAAA,eACAC,EAAAA,wzBAgCLC,KAAKC,UAAWf,EAEjB,ECtEM,MAAMgB,UAA4BlB,EAAAA,IAExCC,YAAaC,GAEZC,MAAO,CAENgB,QAAS,CAERC,UAAW,IACXC,gBAAiB,MAIlBjB,SAAU,CAETkB,QAAS,CAAEhB,MAAO,GAClBiB,OAAQ,CAAEjB,MAAO,MACjBkB,WAAY,CAAElB,MAAO,IAAImB,EAAAA,KACzBC,kBAAmB,CAAEpB,MAAO,IAAIC,EAAAA,KAChCoB,oBAAqB,CAAErB,MAAO,IAAIC,EAAAA,MAInCI,aAAyB,4LAazBC,eAA2B,+3IAqH5BI,KAAKC,UAAWf,EAEjB,EC5JM,MAAM0B,UAA2B5B,EAAAA,IAEvCC,YAAaC,GAEZC,MAAO,CAENgB,QAAS,CAERC,UAAW,IACXC,gBAAiB,MAIlBjB,SAAU,CAETkB,QAAS,CAAEhB,MAAO,GAClBiB,OAAQ,CAAEjB,MAAO,MACLuB,QAAS,CAAEvB,MAAO,MAC9BkB,WAAY,CAAElB,MAAO,IAAImB,EAAAA,KACzBC,kBAAmB,CAAEpB,MAAO,IAAIC,EAAAA,KAChCoB,oBAAqB,CAAErB,MAAO,IAAIC,EAAAA,MAInCI,aAAyB,kLAQzBC,eAA2B,gtLA+G5BI,KAAKC,UAAWf,EAEjB,E,aC/IM,SAAS4B,EAAaC,GACzB,MAAMC,EAAWD,EACdE,KAAKC,GAASC,MAAMD,GAClBE,MAAMC,GAAaA,EAASC,WACjC,OAAOC,QACJC,IAAIR,GACJI,MAAMK,IACLA,EAAMC,QAAQ,qBACd,MAAMJ,EAAOG,EAAME,KAAK,IAClBC,EAAO,IAAIC,KAAK,CAACP,GAAO,CAAEQ,KAAM,oBAEtC,OAAOC,IAAIC,gBAAgBJ,EAAK,GAEtC,C,yGCAI1C,EAAS,CAEd+C,eAAe,EACfC,WAAY,GACZC,OAAQ,GACRC,WAAY,IAAMC,KAClBC,KAAM,aACNhC,SAAU,GACViC,WAAY,KACZC,QAAS,IACTC,YAAa,GACbC,UAAW,GAIZ,IAAIC,EAAUC,EAAQC,EAAOC,EAAKC,EAAOC,EACrCC,EAAUC,EAAWC,EAAQC,EAC7BC,EAAKC,EAAMC,EACXC,EAAiB/D,EAAKgE,EAAUlD,EAAQmD,EAASC,EACjDC,EAAiBC,EAAcC,EAC/BC,EAGAtB,EAAc,GAEduB,EAAU,CAAC,EACfA,EAAUC,EAAQ,KAClB,MAAMC,EAAsB,IAAIC,EAAAA,IAE1BC,EAAYC,SAASC,eAAe,iBACpCC,EAAeF,SAASC,eAAe,gBACvCE,EAASH,SAASC,eAAe,eAEjCG,EAAa,CAClB,UAAWC,EACX,UAAWC,EACX,UAAWC,GAGNhD,EAAOiD,OAAO9C,KAAO8C,OAAOC,UAC5BC,GAAcV,SAASC,eAAe,gBAM5C,IAAIU,GAAoB,GAmJxB,SAASC,KAEJnC,GAEHA,EAAIoC,UAILpC,EAAM,IAAIqC,EAAAA,GAEV,MAAMC,EAAmBtC,EAAIuC,UAAU,cACvCD,EAAiBE,IAAIpG,EAAQ,iBAC7BkG,EAAiBE,IAAIpG,EAAQ,aAAc,GAAI,IAAK,GACpDkG,EAAiBE,IAAIpG,EAAQ,SAAU,EAAG,GAC1CkG,EAAiBE,IAAIpG,EAAQ,cAE7B,MAAMqG,EAAgBzC,EAAIuC,UAAU,WACpCE,EAAcD,IAAIpG,EAAQ,OAAQ,CAAC,WAAY,cAAe,eAAesG,UAAS,KAErFP,IAAY,IAGO,gBAAhB/F,EAAOoD,MAEViD,EAAcD,IAAIpG,EAAQ,WAAa,GAAK,IAGzB,eAAhBA,EAAOoD,MAEViD,EAAcD,IAAIpG,EAAQ,WAAa,GAAK,GAI9C,CAGA,SAASmD,KAER,MAAMoD,EAAMvG,EAAOgD,WACb7C,EAAS,IAAI8E,EAAAA,IACbuB,EAAS,IAAIvB,EAAAA,IACbwB,EAAO,IAAIxB,EAAAA,IACXyB,EAAQ,IAAIzB,EAAAA,IAIlBV,EAASoC,YAAYC,UAAUJ,GAC/BE,EAAMG,WAAWtC,EAASoC,YAAYG,IAAKvC,EAASoC,YAAYI,KAChEL,EAAMM,GAAK,EAAIhH,EAAOiD,OACtByD,EAAMO,GAAK,EAAIjH,EAAOiD,OACtByD,EAAMQ,GAAK,EAAIlH,EAAOiD,OACtB9C,EAAOgH,QAAQX,EAAQC,EAAMC,GAC7B1B,EAAoBoC,KAAKjH,GAAQkH,SAGjCvD,EAAUwD,IAAIF,KAAK7C,EAASoC,aAC5B7C,EAAUwD,IAAIP,IAAIC,GAAKhH,EAAOiD,OAC9Ba,EAAUwD,IAAIP,IAAIE,GAAKjH,EAAOiD,OAC9Ba,EAAUwD,IAAIP,IAAIG,GAAKlH,EAAOiD,OAC9Ba,EAAUwD,IAAIR,IAAIE,GAAKhH,EAAOiD,OAC9Ba,EAAUwD,IAAIR,IAAIG,GAAKjH,EAAOiD,OAC9Ba,EAAUwD,IAAIR,IAAII,GAAKlH,EAAOiD,OAG1B5B,GAEHA,EAAOkG,UAIR,MAAMC,EAAU,EAAIjB,EACdkB,EAAY,GAAMD,EAElBE,EAAY/B,OAAOgC,YAAYC,MACrC,GAAI5H,EAAO+C,cAAe,CAGzB1B,EAAS,IAAI4D,EAAAA,IAA0BsB,EAAKA,EAAKA,GACjDlF,EAAOwG,QAAQC,OAAS7C,EAAAA,IACxB5D,EAAOwG,QAAQjF,KAAOqC,EAAAA,IACtB5D,EAAOwG,QAAQE,UAAY9C,EAAAA,IAC3B5D,EAAOwG,QAAQG,UAAY/C,EAAAA,IAC3B5D,EAAO4G,aAAc,EAGrBvD,EAAgBwD,SAAShI,SAASK,IAAIH,MAAM+H,WAAW5H,GACvDmE,EAAgBwD,SAAShI,SAASC,OAAOC,MAAMgH,KAAKjH,GAGpD,IAAK,IAAIiI,EAAI,EAAGA,EAAI7B,EAAK6B,IAExB1D,EAAgBwD,SAAShI,SAASI,OAAOF,MAAQgI,EAAIZ,EAAUC,EAE/DhE,EAAS4E,gBAAgBhH,EAAQ+G,GACjC1D,EAAgB4D,OAAO7E,GAKxBA,EAAS8E,uBAAuBlH,EAAQ,EAAG,EAAG,EAAG,EAAG,IAAImH,aAAa,IACrE/E,EAAS4E,gBAAgB,KAE1B,KAAO,CAGNhH,EAAS,IAAI4D,EAAAA,IAAoB,IAAIuD,aAAajC,GAAO,GAAIA,EAAKA,EAAKA,GACvElF,EAAOyG,OAAS7C,EAAAA,IAChB5D,EAAOuB,KAAOqC,EAAAA,IACd5D,EAAO0G,UAAY9C,EAAAA,IACnB5D,EAAO2G,UAAY/C,EAAAA,IAEnB,MAAMwD,EAAUlE,EAASmE,WAAWC,SAC9BC,EAAYrE,EAASsE,MACrBC,EAAQ,IAAI7D,EAAAA,IACZ8D,EAAS,IAAI9D,EAAAA,IACb+D,EAAQ,IAAI/D,EAAAA,IACZgE,EAAM,IAAIhE,EAAAA,IACViE,EAAS,CAAC,EAGhB,IAAK,IAAIlC,EAAI,EAAGA,EAAIT,EAAKS,IAExB,IAAK,IAAIC,EAAI,EAAGA,EAAIV,EAAKU,IAExB,IAAK,IAAIC,EAAI,EAAGA,EAAIX,EAAKW,IAAK,CAI7B4B,EAAMK,IACL1B,EAAYT,EAAIQ,EAAU,GAC1BC,EAAYR,EAAIO,EAAU,GAC1BC,EAAYP,EAAIM,EAAU,IACzB4B,aAAajJ,GAEf,MAAM0I,EAAQ7B,EAAIC,EAAIV,EAAMW,EAAIX,EAAMA,EAChC8C,EAAO9I,EAAI+I,oBAAoBR,EAAOI,GAAQK,SAG9CC,EAAYN,EAAOM,UACnBC,EAAKb,EAAUc,KAAiB,EAAZF,EAAgB,GACpCG,EAAKf,EAAUc,KAAiB,EAAZF,EAAgB,GACpCI,EAAKhB,EAAUc,KAAiB,EAAZF,EAAgB,GAC1CP,EAAIY,2BAA2BpB,EAASgB,EAAIE,EAAIC,GAChDX,EAAIa,UAAUf,GACdC,EAAMnC,WAAWqC,EAAOJ,MAAOA,GAG/BzH,EAAO0I,MAAMC,KAAKnB,GAASE,EAAOkB,IAAIjB,GAAS,GAAQK,EAAOA,CAE/D,CAMH,CAGA,MAAML,EAAQrD,OAAOgC,YAAYC,MAAQF,EACzCpD,EAAgB4F,UAAa,GAAElB,EAAMmB,QAAQ,OAE7CpE,IAED,CAiIA,SAASqE,KACU/E,EAAagF,UAAUC,SAAS,cAEjDjF,EAAagF,UAAUE,OAAO,aAC9BlF,EAAamF,UAAY,SACzBnF,EAAagF,UAAUE,OAAO,kBAC9BlF,EAAaoF,UAAW,EAiGzBzG,EAAU0G,iBAAiBC,SAAQ,SAAUC,GAC5CA,EAAMC,OACN7G,EAAU8G,YAAYF,EACvB,IAEA7G,EAASgH,QAAQ7I,MAAK,WAErBiC,EAAI6G,aACJ3G,EAAmB2G,aACnB5G,EAAK4G,aACL7G,OAAM8G,EACN5G,OAAqB4G,EACrB7G,OAAO6G,EACPC,QAAQC,IAAI,wBACb,MA5GC9F,EAAagF,UAAUjE,IAAI,aAC3Bf,EAAamF,UAAY,OACzBnF,EAAagF,UAAUjE,IAAI,kBAO7B,WACC,IAAIgF,UAAUC,aAAaC,aAQ1B,KAAM,2DAPNJ,QAAQC,IAAI,yBACZC,UAAUC,aAAaC,aAAa,CAAEC,OAAO,EAAMC,OAAO,IACxDtJ,KAAKuJ,IACLC,OAAM,SAAUC,GAChB,KAAM,iCAAmCA,CAC1C,GAIH,CAhBEC,GAEF,CAeA,SAASC,KACHvG,EAAOwG,OAyFZ/H,EAASgH,QAAQ7I,MAAK,WAErB+B,EAAO+G,aACP3G,EAAmB2G,aACnB/G,OAASgH,EACT5G,OAAqB4G,CACtB,KArDsB,UAAlBlH,EAASgI,MACZhI,EAAW,IAAIiI,aAEW,aAAlBjI,EAASgI,OACjBhI,EAASkI,SAGVhI,EAASF,EAASmI,yBAAyB5G,GAC3ClB,EAAOL,EAASoI,aAChB/H,EAAKA,KAAKgI,eAAe,EAAGrI,EAASsI,aAOrCzK,EAN6B,CAAC,2EAC7B,mFACA,8GACA,qDAICM,MAAMoK,IACNvI,EAASwI,aAAaC,UAAUF,GAC9BpK,KAAKuK,IACLf,OAAM,SAA4BgB,GAClCxB,QAAQC,IAAK,gEAA+DuB,IAC7E,GAAE,IAEHhB,OAAOgB,IACPxB,QAAQC,IAAK,mEAAkEuB,IAAM,IA9DxF,CACA,SAASjB,GAA2BkB,GAEnC,GADA3I,EAAY2I,GACR3I,EAAU4I,OA8Bb,KAAM,wBA7BgB,UAAlB7I,EAASgI,MACZhI,EAAW,IAAIiI,aAEW,aAAlBjI,EAASgI,OACjBhI,EAASkI,SAGV9H,EAAMJ,EAAS8I,wBAAwB7I,GACvCI,EAAOL,EAASoI,aAChB/H,EAAKA,KAAKgI,eAAe,EAAGrI,EAASsI,aAQrCzK,EAN6B,CAAC,2EAC7B,mFACA,8GACA,qDAICM,MAAMoK,IACNvI,EAASwI,aAAaC,UAAUF,GAC9BpK,KAAK4K,IACLpB,OAAM,SAA4BgB,GAClCxB,QAAQC,IAAK,gEAA+DuB,IAC7E,GAAE,IAEHhB,OAAOgB,IACPxB,QAAQC,IAAK,mEAAkEuB,IAAM,GAKzF,CA0DA,SAASI,KAER,IAAIC,EAAMjI,EAAQkI,WAAWC,sBAAsB1J,KAAkBiF,cACjE0E,EAAK,IAAIpI,EAAQkI,WAAWD,EAAKvE,cACrCtE,EAAc,IAAIY,EAAQqI,YAAYD,GAEtC7I,EAAqB,IAAI+I,iBAAiBrJ,EAAU,2BAA4B,CAC/EsJ,iBAAkB,CACjBhK,WAzlBc,KA0lBdC,QAzlBW,IA0lBXC,YAAaA,EACb+J,WAAYvJ,EAASuJ,cAIvB,IACCjJ,EAAmBkJ,KAAKC,YAAY,CACnCT,IAAKA,GAMP,CAJE,MAAOU,GAGR,OAFAC,MAAM,oEACNrI,EAAaoF,UAAW,EAEzB,CACAtG,EAAIwJ,QAAQtJ,GACZA,EAAmBsJ,QAAQvJ,GAC3BA,EAAKuJ,QAAQ5J,EAAS6J,YACvB,CAEA,SAASnB,KAER,IAAIM,EAAMjI,EAAQkI,WAAWC,sBAAsB1J,KAAkBiF,cACjE0E,EAAK,IAAIpI,EAAQkI,WAAWD,EAAKvE,cACrCtE,EAAc,IAAIY,EAAQqI,YAAYD,GACtC7I,EAAqB,IAAI+I,iBAAiBrJ,EAAU,2BAA4B,CAC/EsJ,iBAAkB,CACjBhK,WAAY,KACZC,QAAS,IACTC,YAAaA,EACb+J,WAAYvJ,EAASuJ,cAGvB,IACCjJ,EAAmBkJ,KAAKC,YAAY,CACnCT,IAAKA,GAKP,CAHE,MAAOU,GAER,YADAC,MAAM,8DAEP,CAEAzJ,EAAO0J,QAAQ5J,EAAS6J,aAExB3J,EAAO0J,QAAQtJ,GACfA,EAAmBsJ,QAAQvJ,GAC3BA,EAAKuJ,QAAQ5J,EAAS6J,YACvB,EA3mBA,WAECtJ,EAAkBa,SAASC,eAAe,UAG1C3B,EAAW,IAAIwB,EAAAA,IAAoB,CAAE4I,WAAW,IAChDpK,EAASqK,cAAcnI,OAAOoI,kBAC9BtK,EAASuK,QAAQrI,OAAOsI,WAAYtI,OAAOuI,aAC3CzK,EAAS0K,cAAc,EAAG,GAC1B1K,EAAS2K,eAAiBnJ,EAAAA,IAC1BE,SAASkJ,KAAKC,YAAY7K,EAAS8K,YAGnC5K,EAAQ,IAAIsB,EAAAA,IAEZ,MAAMuJ,EAAQ,IAAIvJ,EAAAA,IAAuB,SAAU,GACnDuJ,EAAM7F,SAASQ,IAAI,EAAG,EAAG,GACzBxF,EAAMyC,IAAIoI,GACV7K,EAAMyC,IAAI,IAAInB,EAAAA,IAAmB,SAAU,KAG3CvB,EAAS,IAAIuB,EAAAA,IAAwB,GAAIU,OAAOsI,WAAatI,OAAOuI,YAAa,GAAK,IACtFxK,EAAOiF,SAASQ,IAAI,EAAG,EAAG,GAC1BzF,EAAO+K,IAAM,IACb/K,EAAOgL,yBAEP5K,EAAY,IAAImB,EAAAA,GAAiB,IAAIA,EAAAA,KACrCtB,EAAMyC,IAAItC,GACV,MAAM6K,EAAa,IAAI1J,EAAAA,IAAiB,GACxCtB,EAAMyC,IAAIuI,GAEV,IAAIC,EAAAA,EAAclL,EAAQD,EAAS8K,YAGnC1K,EAAQ,IAAIgL,KAKZnK,EAAkB,IAAIoK,EAAAA,EAAe,IAAIjP,GAIzC8E,EAAe,IAAImK,EAAAA,EAAe,IAAI9N,GAGtC4D,EAAc,IAAIkK,EAAAA,EAAe,IAAIpN,GAGrCmD,EAAsB,IAAIkK,EAAAA,GAE1B,IAAIC,EAAAA,GACFC,kBAAkBC,EAAAA,GAClBC,UAAU,iGACVjN,MAAKkN,IAELA,EAAKzL,MAAM0L,mBAAkB,GAE7B,MAAMC,EAAY,IAAIC,EAAAA,EAAwBH,EAAKzL,OAMnD,OALA2L,EAAU5G,WAAa,CAAC,WAAY,UACpC4G,EAAUE,WAAY,EAEtBjL,EAAW+K,EAAUG,WAAWjJ,SAEzB3B,EAAoB4K,SAASlL,EAAU,CAAEmL,YAAa,GAAI,IAGjExN,MAAKyN,IAELpP,EAAMoP,EAENlL,EAAO,IAAIQ,EAAAA,IAAWV,EAAU,IAAIU,EAAAA,KACpCtB,EAAMyC,IAAI3B,GAEVtB,IAAW,IAIb4C,KAIA,IAAI6J,EAAgBxE,eACeH,IAA/B2E,EAAcvE,eACjBuE,EAAcvE,aAAe,CAAC,GAE/B,IACCW,aAAerG,OAAOqG,cAAgBrG,OAAOkK,mBAC7C9L,EAAW,IAAIiI,YAGhB,CAFE,MAAO8D,GACR,KAAM,uCAAyCA,EAAEnE,OAClD,CACArG,EAAOyK,IAAMxK,EAAW,WACxBD,EAAO0K,OA2BR,SAA2BC,EAAOC,GAEjC1L,EAAU,IAAIS,EAAAA,IAAkB,IAAIkL,WAAWF,KArJhC,EAyHc1M,IA6B7BiB,EAAQsD,OAAS7C,EAAAA,IAEjBT,EAAQuD,UAAY9C,EAAAA,IACpBT,EAAQwD,UAAY/C,EAAAA,IACpBT,EAAQ4L,gBAAkB,EAC1B5L,EAAQyD,aAAc,EAEtB,IAAIoI,EAAS,EACb,IAAK,IAAIpJ,EAAI,EAAGA,EArCa1D,GAqCD0D,IAC3B,IAAK,IAAID,EAAI,EAAGA,EA/JF,EA+JaA,IAC1BxC,EAAQ6L,EAAS,GAAK,IACtB7L,EAAQ6L,EAAS,GAAK,EACtB7L,EAAQ6L,EAAS,GAAK,EACtB7L,EAAQ6L,EAAS,GAAK,IACtBA,GAAU,CAGb,CA9CCC,GACA3K,OAAO4K,iBAAiB,UAAU,WAEjC7M,EAAO8M,OAAS7K,OAAOsI,WAAatI,OAAOuI,YAC3CxK,EAAOgL,yBAEPjL,EAASuK,QAAQrI,OAAOsI,WAAYtI,OAAOuI,YAE5C,IAAG,GACH7I,EAAakL,iBAAiB,QAASnG,IACvC9E,EAAOiL,iBAAiB,OAAQ1E,IAChCvG,EAAOiL,iBAAiB,QAAS1E,IACjC3G,EAAUqL,iBAAiB,UAAU,KAnHtC,IAAoBE,IAmHqCvL,EAlHxDI,EAAOyK,IAAMrN,EAAKI,gBAAgB2N,EAAa5O,MAAM,IACrDyD,EAAO0K,MAiH2D,IAClEnK,GAAY0K,iBAAiB,SAAUT,IAEC,WAAtBA,EAAE5G,OAAOwH,WAK1BpL,EAAOyK,IAAMxK,EAAWuK,EAAE5G,OAAOyH,IACjCrL,EAAO0K,OAAM,GAIf,CA1HAY,GA0UA,SAAStI,IAKR,GAHAzE,EAAMgN,SACNC,sBAAsBxI,GAEhBjH,EAKC,GAAoB,aAAhBrB,EAAOoD,KAGjBK,EAAS6E,OAAO3E,EAAOD,QAEjB,GAAoB,gBAAhB1D,EAAOoD,KAAwB,CAMzC,IAAI2N,EAHJrN,EAAO2L,oBACP5K,EAAK4K,oBAKJ0B,EAFG1P,EAAO2P,gBAEJ3P,EAIAA,EAAOwG,QAId,MAAM,MAAEoI,EAAK,MAAEgB,EAAK,OAAEf,GAAWa,EAAIhH,MACrCpF,EAAauD,SAAShI,SAASmB,OAAOjB,MAAQ2Q,EAC9C7F,QAAQC,IACRxG,EAAauD,SAAShI,SAASoB,WAAWlB,MAAM+I,IAAI,EAAI8G,EAAO,EAAIC,EAAQ,EAAIe,GAC/EtM,EAAauD,SAAShI,SAASkB,QAAQhB,MAAQJ,EAAOoB,QACtDuD,EAAauD,SAAShI,SAASsB,kBAAkBpB,MAAMgH,KAAK1D,EAAOwN,yBACnEvM,EAAauD,SAAShI,SAASuB,oBAAoBrB,MAAMgH,KAAK3C,EAAK0M,aAAa9J,SAAS+J,YAAYpM,GAAqBqM,SAAS3N,EAAOyN,aAC1IxM,EAAa2D,OAAO7E,EAErB,MAAO,GAAoB,eAAhBzD,EAAOoD,KAAuB,CACxC,IAAIkO,EAAoB,IAAI9I,aAAajF,QACrB0H,IAAhB/G,GACCA,EAAYqN,kBAAoBhO,GAEpB,IADFW,EAAYsN,QAAQF,KAGhCxL,GAAoBwL,EAAkBvP,KAAIiF,GAAKyK,KAAKC,MAAU,KAAJ1K,MAK7D,MAAM2K,EAvZQ,EAwZRC,EAAUrO,EAChBiB,EAAU,IAAIS,EAAAA,IAAkB,IAAIkL,WAAWwB,EAASC,EAAU,GAAID,EAAQC,GAC9EpN,EAAQsD,OAAS7C,EAAAA,IAEjBT,EAAQuD,UAAY9C,EAAAA,IACpBT,EAAQwD,UAAY/C,EAAAA,IACpBT,EAAQ4L,gBAAkB,EAC1B5L,EAAQyD,aAAc,EACTzD,EAAQuF,MAAMC,KAC3B,IAoBI+G,EApBAV,EAAS,EACb,IAAK,IAAIpJ,EAAI,EAAGA,EAAI2K,EAAS3K,IAC5B,IAAK,IAAID,EAAI,EAAGA,EAAI2K,EAAQ3K,IAG1BxC,EAAQuF,MAAMC,KAAKqG,GAFhBrJ,EAAI2K,EAAS,EAEanN,EAAQuF,MAAMC,KAAKqG,EAAS,GAG5BvK,GAAkBmB,GAEhDzC,EAAQuF,MAAMC,KAAKqG,EAAS,GAAK,EACjC7L,EAAQuF,MAAMC,KAAKqG,EAAS,GAAK,EACjC7L,EAAQuF,MAAMC,KAAKqG,EAAS,GAAK,EACjCA,GAAU,EAIZ3M,EAAO2L,oBACP5K,EAAK4K,oBAKJ0B,EAFG1P,EAAO2P,gBAEJ3P,EAIAA,EAAOwG,QAId,MAAM,MAAEoI,EAAK,MAAEgB,EAAK,OAAEf,GAAWa,EAAIhH,MACrCnF,EAAYsD,SAAShI,SAASmB,OAAOjB,MAAQ2Q,EAAIlJ,QACjDjD,EAAYsD,SAAShI,SAASyB,QAAQvB,MAAQoE,EAC9CI,EAAYsD,SAAShI,SAASoB,WAAWlB,MAAM+I,IAAI,EAAI8G,EAAO,EAAIC,EAAQ,EAAIe,GAC9ErM,EAAYsD,SAAShI,SAASkB,QAAQhB,MAAQJ,EAAOoB,QACrDwD,EAAYsD,SAAShI,SAASsB,kBAAkBpB,MAAMgH,KAAK1D,EAAOwN,yBAClEtM,EAAYsD,SAAShI,SAASuB,oBAAoBrB,MAAMgH,KAAK3C,EAAK0M,aAAa9J,SAAS+J,YAAYpM,GAAqBqM,SAAS3N,EAAOyN,aACzIvM,EAAY0D,OAAO7E,EAEpB,CACD,CAjbA6E,E,cChEAuJ,OAAOC,eAAehN,EAAS,aAA/B+M,CAA+CzR,OAAO,IA6UtD0E,EAAQqI,YA/PR,MACEpN,YAAYgS,GACV,GAAsB,gBAAlBA,EAAQnP,OACV,KAAM,oDAER9B,KAAKiR,QAAUA,CACjB,CAIAP,QAAQQ,GACN,OAAIlR,KAAKiR,QAAQE,QACR,EAEFnR,KAAKiR,QAAQG,IAAIF,EAC1B,CAGAT,iBACE,OAAOzQ,KAAKiR,QAAQR,gBACtB,GA4OFzM,EAAQqN,YAvRR,MAGEpS,YAAYgS,GACV,GAAsB,gBAAlBA,EAAQnP,OACV,KAAM,oDAER9B,KAAKiR,QAAUA,CACjB,CAKAK,QAAQJ,GACN,OAAOlR,KAAKiR,QAAQM,KAAKL,EAC3B,CAGAM,kBACE,OAAOxR,KAAKiR,QAAQO,iBACtB,GAoQFxN,EAAQyN,gBA7LR,MACExS,YAAYgS,GAEVjR,KAAKiR,QAAUA,EACfjR,KAAK0R,IAAM,IAAIC,YAFM,GAGrB3R,KAAK4R,MAAQ,IAAIvC,WAAWrP,KAAK0R,KACjC1R,KAAK6R,KAAO,IAAIC,SAAS9R,KAAK0R,IAChC,CACAK,eAAeC,GACb,OAAIhS,KAAKiR,QAAQE,UAGRnR,KAAKiR,QAAQG,IAAIpR,KAAK4R,OAC/BI,EAAEjK,MAAQ/H,KAAK6R,KAAKI,SAAS,GAC7BD,EAAE1S,MAAQU,KAAK6R,KAAKK,WAAW,IAExB,EACT,GA6KFlO,EAAQmO,gBAzNR,MAGElT,YAAYgS,GACV,GAAsB,cAAlBA,EAAQnP,OACV,KAAM,kDAGR9B,KAAKiR,QAAUA,EACfjR,KAAK0R,IAAM,IAAIC,YAFM,GAGrB3R,KAAK4R,MAAQ,IAAIvC,WAAWrP,KAAK0R,KACjC1R,KAAK6R,KAAO,IAAIC,SAAS9R,KAAK0R,IAChC,CAIAU,eAAerK,EAAOzI,GAIpB,OAFAU,KAAK6R,KAAKQ,SAAS,EAAGtK,GACtB/H,KAAK6R,KAAKS,WAAW,EAAGhT,KACpBU,KAAKiR,QAAQO,kBAHI,OAMdxR,KAAKiR,QAAQM,KAAKvR,KAAK4R,MAChC,GAkMF5N,EAAQkI,WAtKR,MACEqG,6BAA6BC,EAAU1Q,GACrC,IAAKA,EAAK2Q,kBACR,KAAM,iCAER,IAAIC,EAAQ,GAAKF,EAAW,GAAK1Q,EAAK2Q,kBACtC,OAAO,IAAIE,kBAAkBD,EAC/B,CAGAzT,YAAYgN,EAAKnK,GACf,IAAK6P,YAAYiB,UAAUC,cAAc/Q,SACZqI,IAA3BrI,EAAK2Q,kBACL,KAAM,uDAQRzS,KAAK8S,MAAQhR,EACb9B,KAAKwS,UAAYvG,EAAI8G,WAAa,GAAKjR,EAAK2Q,kBAC5CzS,KAAKkR,IAAMjF,EACXjM,KAAKgT,UAAY,IAAIC,YAAYjT,KAAKkR,IAAK,EAAG,GAC9ClR,KAAKkT,SAAW,IAAID,YAAYjT,KAAKkR,IAAK,EAAG,GAC7ClR,KAAKmT,QAAU,IAAIrR,EAAK9B,KAAKkR,IAAK,EAAGlR,KAAKwS,SAC5C,CAGA1Q,OACE,OAAO9B,KAAK8S,MAAMM,IACpB,CAIA7B,KAAK8B,GACH,IAAIC,EAAKC,QAAQrE,KAAKlP,KAAKkT,SAAU,GACjCM,EAAKD,QAAQrE,KAAKlP,KAAKgT,UAAW,GAEtC,IAAKQ,EAAK,GAAKxT,KAAKyT,qBAAuBH,EAEzC,OAAO,EAGT,IAAII,EAAW/C,KAAK1K,IAAIjG,KAAK2T,iBAAiBL,EAAIE,GAAKH,EAASO,QAC5DC,EAAalD,KAAK1K,IAAIjG,KAAKyT,oBAAsBD,EAAIE,GACrDI,EAAcJ,EAAWG,EAY7B,OAVA7T,KAAK+T,MAAMV,EAAU,EAAGrT,KAAKmT,QAASK,EAAIK,GAC1C7T,KAAK+T,MAAMV,EAAUQ,EAAY7T,KAAKmT,QAAS,EAAGW,GAGlDP,QAAQS,MACNhU,KAAKgT,UACL,GACCQ,EAAKE,GAAY1T,KAAKyT,qBAGlBC,CACT,CAKAtC,IAAIiC,GACF,IAAIC,EAAKC,QAAQrE,KAAKlP,KAAKkT,SAAU,GACjCM,EAAKD,QAAQrE,KAAKlP,KAAKgT,UAAW,GAEtC,GAAIQ,GAAMF,EACR,OAAO,EAGT,IAAIW,EAAUtD,KAAK1K,IAAIjG,KAAKkU,gBAAgBZ,EAAIE,GAAKH,EAASO,QAE1DC,EAAalD,KAAK1K,IAAIjG,KAAKyT,oBAAsBH,EAAID,EAASO,QAC9DE,EAAcG,EAAUJ,EAO5B,OALA7T,KAAK+T,MAAM/T,KAAKmT,QAASG,EAAID,EAAU,EAAGQ,GAC1C7T,KAAK+T,MAAM/T,KAAKmT,QAAS,EAAGE,EAAUQ,EAAYC,GAElDP,QAAQS,MAAMhU,KAAKkT,SAAU,GAAII,EAAKW,GAAWjU,KAAKyT,qBAE/CQ,CACT,CAIA9C,QACE,IAAImC,EAAKC,QAAQrE,KAAKlP,KAAKkT,SAAU,GAGrC,OAFSK,QAAQrE,KAAKlP,KAAKgT,UAAW,IAEzBM,CACf,CAIAa,OACE,IAAIb,EAAKC,QAAQrE,KAAKlP,KAAKkT,SAAU,GAGrC,OAFSK,QAAQrE,KAAKlP,KAAKgT,UAAW,GAEzB,GAAKhT,KAAKwS,UAAYc,CACrC,CAIAd,WACE,OAAOxS,KAAKwS,SAAW,CACzB,CAKA/B,iBACE,IAAI6C,EAAKC,QAAQrE,KAAKlP,KAAKkT,SAAU,GACjCM,EAAKD,QAAQrE,KAAKlP,KAAKgT,UAAW,GACtC,OAAOhT,KAAKkU,gBAAgBZ,EAAIE,EAClC,CAKAhC,kBACE,IAAI8B,EAAKC,QAAQrE,KAAKlP,KAAKkT,SAAU,GACjCM,EAAKD,QAAQrE,KAAKlP,KAAKgT,UAAW,GACtC,OAAOhT,KAAK2T,iBAAiBL,EAAIE,EACnC,CAKAU,gBAAgBZ,EAAIE,GAClB,OAAIA,EAAKF,EACAE,EAAKF,EAELE,EAAKxT,KAAKyT,oBAAsBH,CAE3C,CAGAK,iBAAiBL,EAAIE,GACnB,IAAIY,EAAKd,EAAKE,EAAK,EAInB,OAHIA,GAAMF,IACRc,GAAMpU,KAAKyT,qBAENW,CACT,CAGAX,oBACE,OAAOzT,KAAKwS,QACd,CAIAuB,MAAMM,EAAOC,EAAcC,EAAQC,EAAeC,GAChD,IAAK,IAAInN,EAAI,EAAGA,EAAImN,EAAMnN,IACxBiN,EAAOC,EAAgBlN,GAAK+M,EAAMC,EAAehN,EAErD,GAQFtD,EAAQ0Q,aA5TR,SAAsBL,EAAOE,GAC3B,IAAII,EAAgBN,EAAMT,OAAS,IACnC,GAAIW,EAAOX,QAAUe,EACnB,KAAM,oCAER,IAAK,IAAIrN,EAAI,EAAGA,EAAIsN,aAActN,IAAK,CACrC,IAAIuN,EAAcN,EAAOjN,GACrBwN,EAAkBxN,EACtB,IAAK,IAAIyN,EAAI,EAAGA,EAAI,MAAOA,EACzBF,EAAYE,GAAKV,EAAMS,GACvBA,GAAmBH,CAEvB,CACF,EAgTA3Q,EAAQgR,WAzSR,SAAoBX,EAAOE,GACzB,GAAmB,IAAfF,EAAMT,QAAgBW,EAAOX,OAC/B,KAAM,yCAGR,IADA,IAAIqB,EAAU,EACL3N,EAAI,EAAGA,EAAI,IAAKA,IACvB,KAAsByN,EAAIR,EAAOX,OAAQmB,IACvCR,EAAOU,GAAWZ,EADD,GACgB/M,GACjC2N,GAGN,C,GCtDIC,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBjL,IAAjBkL,EACH,OAAOA,EAAarR,QAGrB,IAAIsR,EAASJ,EAAyBE,GAAY,CAGjDpR,QAAS,CAAC,GAOX,OAHAuR,EAAoBH,GAAUI,KAAKF,EAAOtR,QAASsR,EAAQA,EAAOtR,QAASmR,GAGpEG,EAAOtR,OACf,CAGAmR,EAAoBM,EAAIF,EPzBpBzW,EAAW,GACfqW,EAAoBO,EAAI,CAAC7G,EAAQ8G,EAAUC,EAAIC,KAC9C,IAAGF,EAAH,CAMA,IAAIG,EAAeC,IACnB,IAASzO,EAAI,EAAGA,EAAIxI,EAAS8U,OAAQtM,IAAK,CAGzC,IAFA,IAAKqO,EAAUC,EAAIC,GAAY/W,EAASwI,GACpC0O,GAAY,EACPjB,EAAI,EAAGA,EAAIY,EAAS/B,OAAQmB,MACpB,EAAXc,GAAsBC,GAAgBD,IAAa9E,OAAOkF,KAAKd,EAAoBO,GAAGQ,OAAOC,GAAShB,EAAoBO,EAAES,GAAKR,EAASZ,MAC9IY,EAASS,OAAOrB,IAAK,IAErBiB,GAAY,EACTH,EAAWC,IAAcA,EAAeD,IAG7C,GAAGG,EAAW,CACblX,EAASsX,OAAO9O,IAAK,GACrB,IAAI+O,EAAIT,SACEzL,IAANkM,IAAiBxH,EAASwH,EAC/B,CACD,CACA,OAAOxH,CAnBP,CAJCgH,EAAWA,GAAY,EACvB,IAAI,IAAIvO,EAAIxI,EAAS8U,OAAQtM,EAAI,GAAKxI,EAASwI,EAAI,GAAG,GAAKuO,EAAUvO,IAAKxI,EAASwI,GAAKxI,EAASwI,EAAI,GACrGxI,EAASwI,GAAK,CAACqO,EAAUC,EAAIC,EAqBjB,EQzBdV,EAAoBmB,EAAKhB,IACxB,IAAIiB,EAASjB,GAAUA,EAAOkB,WAC7B,IAAOlB,EAAiB,QACxB,IAAM,EAEP,OADAH,EAAoBsB,EAAEF,EAAQ,CAAEG,EAAGH,IAC5BA,CAAM,ECLdpB,EAAoBsB,EAAI,CAACzS,EAAS2S,KACjC,IAAI,IAAIR,KAAOQ,EACXxB,EAAoBnD,EAAE2E,EAAYR,KAAShB,EAAoBnD,EAAEhO,EAASmS,IAC5EpF,OAAOC,eAAehN,EAASmS,EAAK,CAAES,YAAY,EAAMC,IAAKF,EAAWR,IAE1E,ECLDhB,EAAoB2B,EAAKC,GAEjB,iCCHR5B,EAAoBnD,EAAI,CAACgF,EAAKC,IAAUlG,OAAOmG,UAAUC,eAAe3B,KAAKwB,EAAKC,GCAlF9B,EAAoBiC,EAAI,c,MCAxBjC,EAAoBkC,EAAIhT,SAASiT,SAAWC,KAAKC,SAASC,KAK1D,IAAIC,EAAkB,CACrB,IAAK,GAaNvC,EAAoBO,EAAEX,EAAKgC,GAA0C,IAA7BW,EAAgBX,GAGxD,IAAIY,EAAuB,CAACC,EAA4B1O,KACvD,IAGIkM,EAAU2B,GAHTpB,EAAUkC,EAAaC,GAAW5O,EAGhB5B,EAAI,EAC3B,GAAGqO,EAASoC,MAAMlI,GAAgC,IAAxB6H,EAAgB7H,KAAa,CACtD,IAAIuF,KAAYyC,EACZ1C,EAAoBnD,EAAE6F,EAAazC,KACrCD,EAAoBM,EAAEL,GAAYyC,EAAYzC,IAGhD,GAAG0C,EAAS,IAAIjJ,EAASiJ,EAAQ3C,EAClC,CAEA,IADGyC,GAA4BA,EAA2B1O,GACrD5B,EAAIqO,EAAS/B,OAAQtM,IACzByP,EAAUpB,EAASrO,GAChB6N,EAAoBnD,EAAE0F,EAAiBX,IAAYW,EAAgBX,IACrEW,EAAgBX,GAAS,KAE1BW,EAAgBX,GAAW,EAE5B,OAAO5B,EAAoBO,EAAE7G,EAAO,EAGjCmJ,EAAqBT,KAAmB,aAAIA,KAAmB,cAAK,GACxES,EAAmBnO,QAAQ8N,EAAqBM,KAAK,KAAM,IAC3DD,EAAmBzG,KAAOoG,EAAqBM,KAAK,KAAMD,EAAmBzG,KAAK0G,KAAKD,G,KC7CvF,IAAIE,EAAsB/C,EAAoBO,OAAEvL,EAAW,CAAC,IAAI,IAAI,IAAI,MAAM,IAAOgL,EAAoB,OACzG+C,EAAsB/C,EAAoBO,EAAEwC,E","sources":["webpack:///webpack/runtime/chunk loaded","webpack:///./src/utils/GenerateSDFMaterial.js","webpack:///./src/utils/RayMarchSDFMaterial.js","webpack:///./src/utils/RayCastSDFMaterial.js","webpack:///./src/utils/AudioWorkletFunctions.js","webpack:///./src/playground/script.js","webpack:///./src/utils/ringbuf.js/index.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/get javascript chunk filename","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/publicPath","webpack:///webpack/runtime/jsonp chunk loading","webpack:///webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// https://github.com/gkjohnson/three-mesh-bvh/blob/master/example/utils/GenerateSDFMaterial.js\nimport { ShaderMaterial, Matrix4 } from 'three';\nimport { shaderIntersectFunction, shaderDistanceFunction, shaderStructs} from 'three-mesh-bvh/src/gpu/shaderFunctions.js'\nimport { MeshBVHUniformStruct } from 'three-mesh-bvh/src/gpu/MeshBVHUniformStruct.js';\n\nexport class GenerateSDFMaterial extends ShaderMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\n\t\t\tuniforms: {\n\n\t\t\t\tmatrix: { value: new Matrix4() },\n\t\t\t\tzValue: { value: 0 },\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() }\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tprecision highp isampler2D;\n\t\t\t\tprecision highp usampler2D;\n\n\t\t\t\t${ shaderStructs }\n\t\t\t\t${ shaderIntersectFunction }\n\t\t\t\t${ shaderDistanceFunction }\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tuniform BVH bvh;\n\t\t\t\tuniform float zValue;\n\t\t\t\tuniform mat4 matrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// compute the point in space to check\n\t\t\t\t\tvec3 point = vec3( vUv, zValue );\n\t\t\t\t\tpoint -= vec3( 0.5 );\n\t\t\t\t\tpoint = ( matrix * vec4( point, 1.0 ) ).xyz;\n\n\t\t\t\t\t// retrieve the distance and other values\n\t\t\t\t\tuvec4 faceIndices;\n\t\t\t\t\tvec3 faceNormal;\n\t\t\t\t\tvec3 barycoord;\n\t\t\t\t\tfloat side;\n\t\t\t\t\tvec3 outPoint;\n\t\t\t\t\tfloat dist = bvhClosestPointToPoint( bvh, point.xyz, faceIndices, faceNormal, barycoord, side, outPoint );\n\n\t\t\t\t\t// if the triangle side is the back then it must be on the inside and the value negative\n\t\t\t\t\tgl_FragColor = vec4( side * dist, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n","// https://github.com/gkjohnson/three-mesh-bvh/blob/master/example/utils/RayMarchSDFMaterial.js\nimport { ShaderMaterial, Matrix4, Vector3 } from 'three';\n\nexport class RayMarchSDFMaterial extends ShaderMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\n\t\t\tdefines: {\n\n\t\t\t\tMAX_STEPS: 500,\n\t\t\t\tSURFACE_EPSILON: 0.001,\n\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\tsurface: { value: 0 },\n\t\t\t\tsdfTex: { value: null },\n\t\t\t\tnormalStep: { value: new Vector3() },\n\t\t\t\tprojectionInverse: { value: new Matrix4() },\n\t\t\t\tsdfTransformInverse: { value: new Matrix4() }\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tprecision highp sampler3D;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\tuniform float surface;\n\t\t\t\tuniform sampler3D sdfTex;\n\t\t\t\tuniform vec3 normalStep;\n\t\t\t\tuniform mat4 projectionInverse;\n\t\t\t\tuniform mat4 sdfTransformInverse;\n\n\t\t\t\t#include <common>\n\n\t\t\t\t// distance to box bounds\n\t\t\t\tvec2 rayBoxDist( vec3 boundsMin, vec3 boundsMax, vec3 rayOrigin, vec3 rayDir ) {\n\n\t\t\t\t\tvec3 t0 = ( boundsMin - rayOrigin ) / rayDir;\n\t\t\t\t\tvec3 t1 = ( boundsMax - rayOrigin ) / rayDir;\n\t\t\t\t\tvec3 tmin = min( t0, t1 );\n\t\t\t\t\tvec3 tmax = max( t0, t1 );\n\n\t\t\t\t\tfloat distA = max( max( tmin.x, tmin.y ), tmin.z );\n\t\t\t\t\tfloat distB = min( tmax.x, min( tmax.y, tmax.z ) );\n\n\t\t\t\t\tfloat distToBox = max( 0.0, distA );\n\t\t\t\t\tfloat distInsideBox = max( 0.0, distB - distToBox );\n\t\t\t\t\treturn vec2( distToBox, distInsideBox );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t// get the inverse of the sdf box transform\n\t\t\t\t\tmat4 sdfTransform = inverse( sdfTransformInverse );\n\n\t\t\t\t\t// convert the uv to clip space for ray transformation\n\t\t\t\t\tvec2 clipSpace = 2.0 * vUv - vec2( 1.0 );\n\n\t\t\t\t\t// get world ray direction\n\t\t\t\t\tvec3 rayOrigin = vec3( 0.0 );\n\t\t\t\t\tvec4 homogenousDirection = projectionInverse * vec4( clipSpace, - 1.0, 1.0 );\n\t\t\t\t\tvec3 rayDirection = normalize( homogenousDirection.xyz / homogenousDirection.w );\n\n\t\t\t\t\t// transform ray into local coordinates of sdf bounds\n\t\t\t\t\tvec3 sdfRayOrigin = ( sdfTransformInverse * vec4( rayOrigin, 1.0 ) ).xyz;\n\t\t\t\t\tvec3 sdfRayDirection = normalize( ( sdfTransformInverse * vec4( rayDirection, 0.0 ) ).xyz );\n\n\t\t\t\t\t// find whether our ray hits the box bounds in the local box space\n\t\t\t\t\tvec2 boxIntersectionInfo = rayBoxDist( vec3( - 0.5 ), vec3( 0.5 ), sdfRayOrigin, sdfRayDirection );\n\t\t\t\t\tfloat distToBox = boxIntersectionInfo.x;\n\t\t\t\t\tfloat distInsideBox = boxIntersectionInfo.y;\n\t\t\t\t\tbool intersectsBox = distInsideBox > 0.0;\n\n\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\tif ( intersectsBox ) {\n\n\t\t\t\t\t\t// find the surface point in world space\n\t\t\t\t\t\tbool intersectsSurface = false;\n\t\t\t\t\t\tvec4 localPoint = vec4( sdfRayOrigin + sdfRayDirection * ( distToBox + 1e-5 ), 1.0 );\n\t\t\t\t\t\tvec4 point = sdfTransform * localPoint;\n\n\t\t\t\t\t\t// ray march\n\t\t\t\t\t\tfor ( int i = 0; i < MAX_STEPS; i ++ ) {\n\n\t\t\t\t\t\t\t// sdf box extends from - 0.5 to 0.5\n\t\t\t\t\t\t\t// transform into the local bounds space [ 0, 1 ] and check if we're inside the bounds\n\t\t\t\t\t\t\tvec3 uv = ( sdfTransformInverse * point ).xyz + vec3( 0.5 );\n\t\t\t\t\t\t\tif ( uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || uv.z < 0.0 || uv.z > 1.0 ) {\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// get the distance to surface and exit the loop if we're close to the surface\n\t\t\t\t\t\t\tfloat distanceToSurface = texture2D( sdfTex, uv ).r - surface;\n\t\t\t\t\t\t\tif ( distanceToSurface < SURFACE_EPSILON ) {\n\n\t\t\t\t\t\t\t\tintersectsSurface = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// step the ray\n\t\t\t\t\t\t\tpoint.xyz += rayDirection * abs( distanceToSurface );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the surface normal\n\t\t\t\t\t\tif ( intersectsSurface ) {\n\n\t\t\t\t\t\t\t// compute the surface normal\n\t\t\t\t\t\t\tvec3 uv = ( sdfTransformInverse * point ).xyz + vec3( 0.5 );\n\t\t\t\t\t\t\tfloat dx = texture( sdfTex, uv + vec3( normalStep.x, 0.0, 0.0 ) ).r - texture( sdfTex, uv - vec3( normalStep.x, 0.0, 0.0 ) ).r;\n\t\t\t\t\t\t\tfloat dy = texture( sdfTex, uv + vec3( 0.0, normalStep.y, 0.0 ) ).r - texture( sdfTex, uv - vec3( 0.0, normalStep.y, 0.0 ) ).r;\n\t\t\t\t\t\t\tfloat dz = texture( sdfTex, uv + vec3( 0.0, 0.0, normalStep.z ) ).r - texture( sdfTex, uv - vec3( 0.0, 0.0, normalStep.z ) ).r;\n\t\t\t\t\t\t\tvec3 normal = normalize( vec3( dx, dy, dz ) );\n\n\t\t\t\t\t\t\t// compute some basic lighting effects\n\t\t\t\t\t\t\tvec3 lightDirection = normalize( vec3( 1.0 ) );\n\t\t\t\t\t\t\tfloat lightIntensity =\n\t\t\t\t\t\t\t\tsaturate( dot( normal, lightDirection ) ) +\n\t\t\t\t\t\t\t\tsaturate( dot( normal, - lightDirection ) ) * 0.05 +\n\t\t\t\t\t\t\t\t0.1;\n\t\t\t\t\t\t\tgl_FragColor.rgb = vec3( lightIntensity );\n\t\t\t\t\t\t\tgl_FragColor.a = 1.0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t#include <encodings_fragment>\n\n\t\t\t\t}\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}\n","import { ShaderMaterial, Matrix4, Vector3 } from 'three';\n\nexport class RayCastSDFMaterial extends ShaderMaterial {\n\n\tconstructor( params ) {\n\n\t\tsuper( {\n\n\t\t\tdefines: {\n\n\t\t\t\tMAX_STEPS: 100,\n\t\t\t\tSURFACE_EPSILON: 0.001,\n\n\t\t\t},\n\n\t\t\tuniforms: {\n\n\t\t\t\tsurface: { value: 0 },\n\t\t\t\tsdfTex: { value: null },\n                dataTex: { value: null},\n\t\t\t\tnormalStep: { value: new Vector3() },\n\t\t\t\tprojectionInverse: { value: new Matrix4() },\n\t\t\t\tsdfTransformInverse: { value: new Matrix4() }\n\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\t\tprecision highp sampler3D;\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform float surface;\n\t\t\t\tuniform sampler3D sdfTex;\n                uniform sampler2D dataTex;\n\t\t\t\tuniform vec3 normalStep;\n\t\t\t\tuniform mat4 projectionInverse;\n\t\t\t\tuniform mat4 sdfTransformInverse;\n\t\t\t\t#include <common>\n\t\t\t\t// distance to box bounds\n\t\t\t\tvec2 rayBoxDist( vec3 boundsMin, vec3 boundsMax, vec3 rayOrigin, vec3 rayDir ) {\n\t\t\t\t\tvec3 t0 = ( boundsMin - rayOrigin ) / rayDir;\n\t\t\t\t\tvec3 t1 = ( boundsMax - rayOrigin ) / rayDir;\n\t\t\t\t\tvec3 tmin = min( t0, t1 );\n\t\t\t\t\tvec3 tmax = max( t0, t1 );\n\t\t\t\t\tfloat distA = max( max( tmin.x, tmin.y ), tmin.z );\n\t\t\t\t\tfloat distB = min( tmax.x, min( tmax.y, tmax.z ) );\n\t\t\t\t\tfloat distToBox = max( 0.0, distA );\n\t\t\t\t\tfloat distInsideBox = max( 0.0, distB - distToBox );\n\t\t\t\t\treturn vec2( distToBox, distInsideBox );\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\t// get the inverse of the sdf box transform\n\t\t\t\t\tmat4 sdfTransform = inverse( sdfTransformInverse );\n\t\t\t\t\t// convert the uv to clip space for ray transformation\n\t\t\t\t\tvec2 clipSpace = 2.0 * vUv - vec2( 1.0 );\n\t\t\t\t\t// get world ray direction\n\t\t\t\t\tvec3 rayOrigin = vec3( 0.0 );\n\t\t\t\t\tvec4 homogenousDirection = projectionInverse * vec4( clipSpace, - 1.0, 1.0 );\n\t\t\t\t\tvec3 rayDirection = normalize( homogenousDirection.xyz / homogenousDirection.w );\n\t\t\t\t\t// transform ray into local coordinates of sdf bounds\n\t\t\t\t\tvec3 sdfRayOrigin = ( sdfTransformInverse * vec4( rayOrigin, 1.0 ) ).xyz;\n\t\t\t\t\tvec3 sdfRayDirection = normalize( ( sdfTransformInverse * vec4( rayDirection, 0.0 ) ).xyz );\n\t\t\t\t\t// find whether our ray hits the box bounds in the local box space\n\t\t\t\t\tvec2 boxIntersectionInfo = rayBoxDist( vec3( - 0.5 ), vec3( 0.5 ), sdfRayOrigin, sdfRayDirection );\n\t\t\t\t\tfloat distToBox = boxIntersectionInfo.x;\n\t\t\t\t\tfloat distInsideBox = boxIntersectionInfo.y;\n\t\t\t\t\tbool intersectsBox = distInsideBox > 0.0;\n\t\t\t\t\tgl_FragColor = vec4( 0.0 );\n\t\t\t\t\tif ( intersectsBox ) {\n\t\t\t\t\t\t// find the surface point in world space\n\t\t\t\t\t\tbool intersectsSurface = false;\n\t\t\t\t\t\tvec4 localPoint = vec4( sdfRayOrigin + sdfRayDirection * ( distToBox + 1e-5 ), 1.0 );\n\t\t\t\t\t\tvec4 point = sdfTransform * localPoint;\n\t\t\t\t\t\tint step = 0;\n\t\t\t\t\t\t// ray march\n\t\t\t\t\t\tfor ( int i = 0; i < MAX_STEPS; i ++ ) {\n\t\t\t\t\t\t\t// sdf box extends from - 0.5 to 0.5\n\t\t\t\t\t\t\t// transform into the local bounds space [ 0, 1 ] and check if we're inside the bounds\n\t\t\t\t\t\t\tvec3 uv = ( sdfTransformInverse * point ).xyz + vec3( 0.5 );\n\t\t\t\t\t\t\tif ( uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || uv.z < 0.0 || uv.z > 1.0 ) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// // get the distance to surface and exit the loop if we're close to the surface\n\t\t\t\t\t\t\t// float distanceToSurface = texture2D( sdfTex, uv ).r - surface;\n\t\t\t\t\t\t\t// if ( distanceToSurface < SURFACE_EPSILON ) {\n\t\t\t\t\t\t\t// \tintersectsSurface = true;\n\t\t\t\t\t\t\t// \tbreak;\n\t\t\t\t\t\t\t// }\n                            // get the distance value\n\t\t\t\t\t\t\tfloat distance = abs(texture2D( sdfTex, uv - 0.5).r);\n\t\t\t\t\t\t\tdistance = distance * 0.1; \n\t\t\t\t\t\t\tdistance = clamp(length(uv-vec3(0.5)), 0.0, 1.0);\n\t\t\t\t\t\t\t// sample data texture along distance value\n                            vec2 uv2 = vec2(0., distance);\n                            float dataSample = texture(dataTex, uv2).r;\n\t\t\t\t\t\t\tvec4 baseColor = vec4(pow(dataSample,10.0) * distance,\n\t\t\t\t\t\t\tpow(dataSample, 2.0),\n\t\t\t\t\t\t\tpow(dataSample, 0.0) * distance, dataSample) ;\n\t\t\t\t\t\n\t\t\t\t\t\t\t// vec4 baseColor = vec4(distance,0., 0., 0.4);\n\t\t\t\t\t\t\t// baseColor.rgb = uv;\n\t\t\t\t\t\t\t// baseColor.w = 1.0;\n                            // Opacity correction\n\t\t\t\t\t\t\tbaseColor.w = 1.0 - pow(1.0 - baseColor.w, 0.01);\n                            // Alpha-blending\n                            gl_FragColor.rbg += (1.0 -  gl_FragColor.a) * baseColor.a * baseColor.xyz;\n\t\t\t\t\t\t\tgl_FragColor.a += (1.0 - gl_FragColor.a) * baseColor.w;\n                            // exit the loop if the accumulated alpha is close to 1\n                            // if (gl_FragColor.a > 0.9) {\n                            //   break;\n                            // }\n\t\t\t\t\t\t\t// step the ray\n\t\t\t\t\t\t\tpoint.xyz += rayDirection * 0.01;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// // find the surface normal\n\t\t\t\t\t\t// if ( intersectsSurface ) {\n\t\t\t\t\t\t// \t// compute the surface normal\n\t\t\t\t\t\t// \tvec3 uv = ( sdfTransformInverse * point ).xyz + vec3( 0.5 );\n\t\t\t\t\t\t// \tfloat dx = texture( sdfTex, uv + vec3( normalStep.x, 0.0, 0.0 ) ).r - texture( sdfTex, uv - vec3( normalStep.x, 0.0, 0.0 ) ).r;\n\t\t\t\t\t\t// \tfloat dy = texture( sdfTex, uv + vec3( 0.0, normalStep.y, 0.0 ) ).r - texture( sdfTex, uv - vec3( 0.0, normalStep.y, 0.0 ) ).r;\n\t\t\t\t\t\t// \tfloat dz = texture( sdfTex, uv + vec3( 0.0, 0.0, normalStep.z ) ).r - texture( sdfTex, uv - vec3( 0.0, 0.0, normalStep.z ) ).r;\n\t\t\t\t\t\t// \tvec3 normal = normalize( vec3( dx, dy, dz ) );\n\t\t\t\t\t\t// \t// compute some basic lighting effects\n\t\t\t\t\t\t// \tvec3 lightDirection = normalize( vec3( 1.0 ) );\n\t\t\t\t\t\t// \tfloat lightIntensity =\n\t\t\t\t\t\t// \t\tsaturate( dot( normal, lightDirection ) ) +\n\t\t\t\t\t\t// \t\tsaturate( dot( normal, - lightDirection ) ) * 0.05 +\n\t\t\t\t\t\t// \t\t0.1;\n\t\t\t\t\t\t// \tgl_FragColor.rgb = vec3( lightIntensity );\n\t\t\t\t\t\t// \tgl_FragColor.a = 1.0;\n\t\t\t\t\t\t// }\n\t\t\t\t\t}\n\t\t\t\t\t#include <encodings_fragment>\n\t\t\t\t}\n\t\t\t`\n\n\t\t} );\n\n\t\tthis.setValues( params );\n\n\t}\n\n}","// From a series of URL to js files, get an object URL that can be loaded in an\n// AudioWorklet. This is useful to be able to use multiple files (utils, data\n// structure, main DSP, etc.) without either using static imports, eval, manual\n// concatenation with or without a build step, etc.\nexport function URLFromFiles(files) {\n    const promises = files\n      .map((file) => fetch(file)\n        .then((response) => response.text()));\n    return Promise\n      .all(promises)\n      .then((texts) => {\n        texts.unshift(\"var exports = {};\"); // hack to make injected umd modules work\n        const text = texts.join('');\n        const blob = new Blob([text], { type: \"text/javascript\" });\n  \n        return URL.createObjectURL(blob);\n      });\n  }","import '../style.css';\nimport * as THREE from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\nimport Stats from 'stats-js';\nimport { GenerateMeshBVHWorker } from 'three-mesh-bvh/src/workers/GenerateMeshBVHWorker.js';\nimport { StaticGeometryGenerator } from 'three-mesh-bvh/src/utils/StaticGeometryGenerator.js';\nimport { GenerateSDFMaterial } from '../utils/GenerateSDFMaterial.js';\nimport { RayMarchSDFMaterial } from '../utils/RayMarchSDFMaterial.js';\nimport { RayCastSDFMaterial } from '../utils/RayCastSDFMaterial.js';\nimport { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';\nimport { URLFromFiles } from '../utils/AudioWorkletFunctions.js';\nimport audioFile1 from \"../assets/audio/r2d2_talk.mp3\";\nimport audioFile2 from \"../assets/audio/synth_melody.mp3\";\nimport audioFile3 from \"../assets/audio/theremin_tone.mp3\";\nconst params = {\n\n\tgpuGeneration: true,\n\tresolution: 75,\n\tmargin: 0.2,\n\tregenerate: () => updateSDF(),\n\tmode: 'raycasting',\n\tsurface: -0.3,\n\tbufferSize: 1024,\n\thopSize: 512,\n\tmelNumBands: 96,\n\tnumFrames: 1,\n\n};\n\nlet renderer, camera, scene, gui, stats, boxHelper, axesHelper;\nlet audioCtx, gumStream, source, audioReader;\nlet mic, gain, melspectrogramNode;\nlet outputContainer, bvh, geometry, sdfTex, specTex, mesh;\nlet generateSdfPass, raymarchPass, raycastPass;\nlet bvhGenerationWorker;\nlet bufferSize = 1024;\nlet hopSize = 512;\nlet melNumBands = 96;\nlet numFrames = 1;\nlet exports = {};\nexports = require('../utils/ringbuf.js/index.js');\nconst inverseBoundsMatrix = new THREE.Matrix4();\n\nconst fileInput = document.getElementById('loadFileInput');\nconst recordButton = document.getElementById('recordButton');\nconst player = document.getElementById(\"audioPlayer\");\n\nconst audioFiles = {\n\t\"audio-1\": audioFile1,\n\t\"audio-2\": audioFile2,\n\t\"audio-3\": audioFile3,\n}\n\nconst blob = window.URL || window.webkitURL;\nconst buttonGroup = document.getElementById(\"button-group\");\n\nfunction onLoadFile(inputElement) {\n\tplayer.src = blob.createObjectURL(inputElement.files[0]);\n\tplayer.load();\n}\nlet scaledMelspectrum = [];\n\ninit();\nrender();\n\nfunction init() {\n\n\toutputContainer = document.getElementById('output');\n\n\t// renderer setup\n\trenderer = new THREE.WebGLRenderer({ antialias: true });\n\trenderer.setPixelRatio(window.devicePixelRatio);\n\trenderer.setSize(window.innerWidth, window.innerHeight);\n\trenderer.setClearColor(0, 0);\n\trenderer.outputEncoding = THREE.sRGBEncoding;\n\tdocument.body.appendChild(renderer.domElement);\n\n\t// scene setup\n\tscene = new THREE.Scene();\n\n\tconst light = new THREE.DirectionalLight(0xffffff, 1);\n\tlight.position.set(1, 1, 1);\n\tscene.add(light);\n\tscene.add(new THREE.AmbientLight(0xffffff, 0.2));\n\n\t// camera setup\n\tcamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);\n\tcamera.position.set(1, 1, 2);\n\tcamera.far = 100;\n\tcamera.updateProjectionMatrix();\n\n\tboxHelper = new THREE.Box3Helper(new THREE.Box3());\n\tscene.add(boxHelper);\n\tconst axesHelper = new THREE.AxesHelper(3);\n\tscene.add(axesHelper);\n\n\tnew OrbitControls(camera, renderer.domElement);\n\n\t// stats setup\n\tstats = new Stats();\n\t//document.getElementById('stats').appendChild(stats.dom);\n\t//document.body.appendChild(stats.dom);\n\n\t// sdf pass to generate the 3d texture\n\tgenerateSdfPass = new FullScreenQuad(new GenerateSDFMaterial());\n\n\n\t// screen pass to render the sdf ray marching\n\traymarchPass = new FullScreenQuad(new RayMarchSDFMaterial());\n\n\t// screen pass to render the sdf ray casting\n\traycastPass = new FullScreenQuad(new RayCastSDFMaterial());\n\n\t// load model and generate bvh\n\tbvhGenerationWorker = new GenerateMeshBVHWorker();\n\n\tnew GLTFLoader()\n\t\t.setMeshoptDecoder(MeshoptDecoder)\n\t\t.loadAsync('https://raw.githubusercontent.com/gkjohnson/3d-demo-data/main/models/stanford-bunny/bunny.glb')\n\t\t.then(gltf => {\n\n\t\t\tgltf.scene.updateMatrixWorld(true);\n\n\t\t\tconst staticGen = new StaticGeometryGenerator(gltf.scene);\n\t\t\tstaticGen.attributes = ['position', 'normal'];\n\t\t\tstaticGen.useGroups = false;\n\n\t\t\tgeometry = staticGen.generate().center();\n\n\t\t\treturn bvhGenerationWorker.generate(geometry, { maxLeafTris: 1 });\n\n\t\t})\n\t\t.then(result => {\n\n\t\t\tbvh = result;\n\n\t\t\tmesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial());\n\t\t\tscene.add(mesh);\n\n\t\t\tupdateSDF();\n\n\t\t});\n\n\trebuildGUI();\n\t// Some browsers partially implement mediaDevices. We can't assign an object\n\t// with getUserMedia as it would overwrite existing properties.\n\t// Add the getUserMedia property if it's missing.\n\tlet navigatorCopy = navigator;\n\tif (navigatorCopy.mediaDevices === undefined) {\n\t\tnavigatorCopy.mediaDevices = {};\n\t}\n\ttry {\n\t\tAudioContext = window.AudioContext || window.webkitAudioContext;\n\t\taudioCtx = new AudioContext();\n\t} catch (e) {\n\t\tthrow \"Could not instantiate AudioContext: \" + e.message;\n\t}\n\tplayer.src = audioFiles['audio-1'];\n\tplayer.load();\n\tcreateDataTexture(numFrames, melNumBands);\n\twindow.addEventListener('resize', function () {\n\n\t\tcamera.aspect = window.innerWidth / window.innerHeight;\n\t\tcamera.updateProjectionMatrix();\n\n\t\trenderer.setSize(window.innerWidth, window.innerHeight);\n\n\t}, false);\n\trecordButton.addEventListener('click', onRecordClickHandler);\n\tplayer.addEventListener('play', onPlayClickHandler);\n\tplayer.addEventListener('pause', onPlayClickHandler);\n\tfileInput.addEventListener('change', () => { onLoadFile(fileInput) });\n\tbuttonGroup.addEventListener(\"click\", (e) => {\n\n\t\tconst isButton = e.target.nodeName === 'BUTTON';\n\t\tif (!isButton) {\n\t\t\treturn\n\t\t}\n\n\t\tplayer.src = audioFiles[e.target.id];\n\t\tplayer.load();\n\t});\n\n\n}\nfunction createDataTexture(width, height) {\n\n\tspecTex = new THREE.DataTexture(new Uint8Array(width * height * 4), width, height);\n\tspecTex.format = THREE.RGBAFormat;\n\t// texture.type = THREE.FloatType;\n\tspecTex.minFilter = THREE.LinearFilter;\n\tspecTex.magFilter = THREE.LinearFilter;\n\tspecTex.unpackAlignment = 1;\n\tspecTex.needsUpdate = true;\n\n\tlet stride = 0;\n\tfor (let y = 0; y < height; y++) {\n\t\tfor (let x = 0; x < width; x++) {\n\t\t\tspecTex[stride + 0] = 255;\n\t\t\tspecTex[stride + 1] = 0;\n\t\t\tspecTex[stride + 2] = 0;\n\t\t\tspecTex[stride + 3] = 255;\n\t\t\tstride += 4;\n\t\t}\n\t}\n}\n// build the gui with parameters based on the selected display mode\nfunction rebuildGUI() {\n\n\tif (gui) {\n\n\t\tgui.destroy();\n\n\t}\n\n\tgui = new GUI();\n\n\tconst generationFolder = gui.addFolder('generation');\n\tgenerationFolder.add(params, 'gpuGeneration');\n\tgenerationFolder.add(params, 'resolution', 10, 200, 1);\n\tgenerationFolder.add(params, 'margin', 0, 1);\n\tgenerationFolder.add(params, 'regenerate');\n\n\tconst displayFolder = gui.addFolder('display');\n\tdisplayFolder.add(params, 'mode', ['geometry', 'raymarching', 'raycasting']).onChange(() => {\n\n\t\trebuildGUI();\n\n\t});\n\tif (params.mode === 'raymarching') {\n\n\t\tdisplayFolder.add(params, 'surface', - 0.2, 0.5);\n\n\t}\n\tif (params.mode === 'raycasting') {\n\n\t\tdisplayFolder.add(params, 'surface', - 0.5, 0.5);\n\n\t}\n\n}\n\n// update the sdf texture based on the selected parameters\nfunction updateSDF() {\n\n\tconst dim = params.resolution;\n\tconst matrix = new THREE.Matrix4();\n\tconst center = new THREE.Vector3();\n\tconst quat = new THREE.Quaternion();\n\tconst scale = new THREE.Vector3();\n\n\t// compute the bounding box of the geometry including the margin which is used to\n\t// define the range of the SDF\n\tgeometry.boundingBox.getCenter(center);\n\tscale.subVectors(geometry.boundingBox.max, geometry.boundingBox.min);\n\tscale.x += 2 * params.margin;\n\tscale.y += 2 * params.margin;\n\tscale.z += 2 * params.margin;\n\tmatrix.compose(center, quat, scale);\n\tinverseBoundsMatrix.copy(matrix).invert();\n\n\t// update the box helper\n\tboxHelper.box.copy(geometry.boundingBox);\n\tboxHelper.box.min.x -= params.margin;\n\tboxHelper.box.min.y -= params.margin;\n\tboxHelper.box.min.z -= params.margin;\n\tboxHelper.box.max.x += params.margin;\n\tboxHelper.box.max.y += params.margin;\n\tboxHelper.box.max.z += params.margin;\n\n\t// dispose of the existing sdf\n\tif (sdfTex) {\n\n\t\tsdfTex.dispose();\n\n\t}\n\n\tconst pxWidth = 1 / dim;\n\tconst halfWidth = 0.5 * pxWidth;\n\n\tconst startTime = window.performance.now();\n\tif (params.gpuGeneration) {\n\n\t\t// create a new 3d render target texture\n\t\tsdfTex = new THREE.WebGL3DRenderTarget(dim, dim, dim);\n\t\tsdfTex.texture.format = THREE.RedFormat;\n\t\tsdfTex.texture.type = THREE.FloatType;\n\t\tsdfTex.texture.minFilter = THREE.LinearFilter;\n\t\tsdfTex.texture.magFilter = THREE.LinearFilter;\n\t\tsdfTex.needsUpdate = true;\n\n\t\t// prep the sdf generation material pass\n\t\tgenerateSdfPass.material.uniforms.bvh.value.updateFrom(bvh);\n\t\tgenerateSdfPass.material.uniforms.matrix.value.copy(matrix);\n\n\t\t// render into each layer\n\t\tfor (let i = 0; i < dim; i++) {\n\n\t\t\tgenerateSdfPass.material.uniforms.zValue.value = i * pxWidth + halfWidth;\n\n\t\t\trenderer.setRenderTarget(sdfTex, i);\n\t\t\tgenerateSdfPass.render(renderer);\n\n\t\t}\n\n\t\t// initiate read back to get a rough estimate of time taken to generate the sdf\n\t\trenderer.readRenderTargetPixels(sdfTex, 0, 0, 1, 1, new Float32Array(4));\n\t\trenderer.setRenderTarget(null);\n\n\t} else {\n\n\t\t// create a new 3d data texture\n\t\tsdfTex = new THREE.Data3DTexture(new Float32Array(dim ** 3), dim, dim, dim);\n\t\tsdfTex.format = THREE.RedFormat;\n\t\tsdfTex.type = THREE.FloatType;\n\t\tsdfTex.minFilter = THREE.LinearFilter;\n\t\tsdfTex.magFilter = THREE.LinearFilter;\n\n\t\tconst posAttr = geometry.attributes.position;\n\t\tconst indexAttr = geometry.index;\n\t\tconst point = new THREE.Vector3();\n\t\tconst normal = new THREE.Vector3();\n\t\tconst delta = new THREE.Vector3();\n\t\tconst tri = new THREE.Triangle();\n\t\tconst target = {};\n\n\t\t// iterate over all pixels and check distance\n\t\tfor (let x = 0; x < dim; x++) {\n\n\t\t\tfor (let y = 0; y < dim; y++) {\n\n\t\t\t\tfor (let z = 0; z < dim; z++) {\n\n\t\t\t\t\t// adjust by half width of the pixel so we sample the pixel center\n\t\t\t\t\t// and offset by half the box size.\n\t\t\t\t\tpoint.set(\n\t\t\t\t\t\thalfWidth + x * pxWidth - 0.5,\n\t\t\t\t\t\thalfWidth + y * pxWidth - 0.5,\n\t\t\t\t\t\thalfWidth + z * pxWidth - 0.5,\n\t\t\t\t\t).applyMatrix4(matrix);\n\n\t\t\t\t\tconst index = x + y * dim + z * dim * dim;\n\t\t\t\t\tconst dist = bvh.closestPointToPoint(point, target).distance;\n\n\t\t\t\t\t// get the face normal to determine if the distance should be positive or negative\n\t\t\t\t\tconst faceIndex = target.faceIndex;\n\t\t\t\t\tconst i0 = indexAttr.getX(faceIndex * 3 + 0);\n\t\t\t\t\tconst i1 = indexAttr.getX(faceIndex * 3 + 1);\n\t\t\t\t\tconst i2 = indexAttr.getX(faceIndex * 3 + 2);\n\t\t\t\t\ttri.setFromAttributeAndIndices(posAttr, i0, i1, i2);\n\t\t\t\t\ttri.getNormal(normal);\n\t\t\t\t\tdelta.subVectors(target.point, point);\n\n\t\t\t\t\t// set the distance in the texture data\n\t\t\t\t\tsdfTex.image.data[index] = normal.dot(delta) > 0.0 ? - dist : dist;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// update the timing display\n\tconst delta = window.performance.now() - startTime;\n\toutputContainer.innerText = `${delta.toFixed(2)}ms`;\n\n\trebuildGUI();\n\n}\n// update the spectrum texture based on new data\nfunction updateSpectrum() {\n\tlet melspectrumBuffer = new Float32Array(melNumBands);\n\tif (audioReader !== undefined) {\n\t\tif (audioReader.available_read() >= melNumBands) {\n\t\t\tlet toread = audioReader.dequeue(melspectrumBuffer);\n\t\t\tif (toread !== 0) {\n\t\t\t\t// scale spectrum values to 0 - 255\n\t\t\t\tscaledMelspectrum = melspectrumBuffer.map(x => Math.round(x * 35.5));\n\t\t\t}\n\t\t}\n\t}\n\t// dispose of the existing spectrum texture\n\tif (specTex) {\n\n\t\tspecTex.dispose();\n\n\t}\n\n}\n\nfunction render() {\n\n\tstats.update();\n\trequestAnimationFrame(render);\n\n\tif (!(sdfTex)) {\n\n\t\t// render nothing\n\t\treturn;\n\n\t} else if (params.mode === 'geometry') {\n\n\t\t// render the rasterized geometry\n\t\trenderer.render(scene, camera);\n\n\t} else if (params.mode === 'raymarching') {\n\n\t\t// render the ray marched texture\n\t\tcamera.updateMatrixWorld();\n\t\tmesh.updateMatrixWorld();\n\n\t\tlet tex;\n\t\tif (sdfTex.isData3DTexture) {\n\n\t\t\ttex = sdfTex;\n\n\t\t} else {\n\n\t\t\ttex = sdfTex.texture;\n\n\t\t}\n\n\t\tconst { width, depth, height } = tex.image;\n\t\traymarchPass.material.uniforms.sdfTex.value = tex;\n\t\tconsole.log\n\t\traymarchPass.material.uniforms.normalStep.value.set(1 / width, 1 / height, 1 / depth);\n\t\traymarchPass.material.uniforms.surface.value = params.surface;\n\t\traymarchPass.material.uniforms.projectionInverse.value.copy(camera.projectionMatrixInverse);\n\t\traymarchPass.material.uniforms.sdfTransformInverse.value.copy(mesh.matrixWorld).invert().premultiply(inverseBoundsMatrix).multiply(camera.matrixWorld);\n\t\traymarchPass.render(renderer);\n\n\t} else if (params.mode === 'raycasting') {\n\t\tlet melspectrumBuffer = new Float32Array(melNumBands);\n\t\tif (audioReader !== undefined) {\n\t\t\tif (audioReader.available_read() >= melNumBands) {\n\t\t\t\tlet toread = audioReader.dequeue(melspectrumBuffer);\n\t\t\t\tif (toread !== 0) {\n\t\t\t\t\t// scale spectrum values to 0 - 255\n\t\t\t\t\tscaledMelspectrum = melspectrumBuffer.map(x => Math.round(x * 35.5));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst widthS = numFrames;\n\t\tconst heightS = melNumBands;\n\t\tspecTex = new THREE.DataTexture(new Uint8Array(widthS * heightS * 4), widthS, heightS);\n\t\tspecTex.format = THREE.RGBAFormat;\n\t\t// specTex.type = THREE.FloatType;\n\t\tspecTex.minFilter = THREE.NearestFilter;\n\t\tspecTex.magFilter = THREE.NearestFilter;\n\t\tspecTex.unpackAlignment = 1;\n\t\tspecTex.needsUpdate = true;\n\t\tconst data = specTex.image.data;\n\t\tlet stride = 0;\n\t\tfor (let y = 0; y < heightS; y++) {\n\t\t\tfor (let x = 0; x < widthS; x++) {\n\t\t\t\tif (x < widthS - 1) {\n\t\t\t\t\t// shift the index by 4 to get the color value of the subsequent column\n\t\t\t\t\tspecTex.image.data[stride] = specTex.image.data[stride + 4];\n\t\t\t\t} else {\n\t\t\t\t\t// set the red value of the texture\n\t\t\t\t\tspecTex.image.data[stride] = scaledMelspectrum[y];\n\t\t\t\t}\n\t\t\t\tspecTex.image.data[stride + 1] = 0;\n\t\t\t\tspecTex.image.data[stride + 2] = 0;\n\t\t\t\tspecTex.image.data[stride + 3] = 1;\n\t\t\t\tstride += 4;\n\t\t\t}\n\t\t}\n\t\t// render the ray cast texture\n\t\tcamera.updateMatrixWorld();\n\t\tmesh.updateMatrixWorld();\n\n\t\tlet tex;\n\t\tif (sdfTex.isData3DTexture) {\n\n\t\t\ttex = sdfTex;\n\n\t\t} else {\n\n\t\t\ttex = sdfTex.texture;\n\n\t\t}\n\n\t\tconst { width, depth, height } = tex.image;\n\t\traycastPass.material.uniforms.sdfTex.value = tex.texture;\n\t\traycastPass.material.uniforms.dataTex.value = specTex;\n\t\traycastPass.material.uniforms.normalStep.value.set(1 / width, 1 / height, 1 / depth);\n\t\traycastPass.material.uniforms.surface.value = params.surface;\n\t\traycastPass.material.uniforms.projectionInverse.value.copy(camera.projectionMatrixInverse);\n\t\traycastPass.material.uniforms.sdfTransformInverse.value.copy(mesh.matrixWorld).invert().premultiply(inverseBoundsMatrix).multiply(camera.matrixWorld);\n\t\traycastPass.render(renderer);\n\n\t}\n}\n\n\nfunction onRecordClickHandler() {\n\tconst recording = recordButton.classList.contains(\"recording\");\n\tif (recording) {\n\t\trecordButton.classList.remove(\"recording\");\n\t\trecordButton.innerHTML = \"Record\";\n\t\trecordButton.classList.remove(\"bg-emerald-200\");\n\t\trecordButton.disabled = false;\n\t\tstopMicRecordStream();\n\t} else {\n\t\trecordButton.classList.add(\"recording\");\n\t\trecordButton.innerHTML = \"Stop\";\n\t\trecordButton.classList.add(\"bg-emerald-200\");\n\t\t// start microphone stream using getUserMedia and run feature extraction\n\t\tstartMicRecordStream();\n\t}\n}\n\n// record native microphone input and do further audio processing on each audio buffer using the given callback functions\nfunction startMicRecordStream() {\n\tif (navigator.mediaDevices.getUserMedia) {\n\t\tconsole.log(\"Initializing audio...\");\n\t\tnavigator.mediaDevices.getUserMedia({ audio: true, video: false })\n\t\t\t.then(startAudioProcessingStream)\n\t\t\t.catch(function (message) {\n\t\t\t\tthrow \"Could not access microphone - \" + message;\n\t\t\t});\n\t} else {\n\t\tthrow \"Could not access microphone - getUserMedia not available\";\n\t}\n}\nfunction onPlayClickHandler() {\n\tif (!player.paused) {\n\t\tstartAudioProcessingMediaElt();\n\t} else {\n\t\tstopAudioProcessingMediaElt();\n\t}\n}\nfunction startAudioProcessingStream(stream) {\n\tgumStream = stream;\n\tif (gumStream.active) {\n\t\tif (audioCtx.state == \"closed\") {\n\t\t\taudioCtx = new AudioContext();\n\t\t}\n\t\telse if (audioCtx.state == \"suspended\") {\n\t\t\taudioCtx.resume();\n\t\t}\n\n\t\tmic = audioCtx.createMediaStreamSource(gumStream);\n\t\tgain = audioCtx.createGain();\n\t\tgain.gain.setValueAtTime(0, audioCtx.currentTime);\n\n\t\tlet codeForProcessorModule = [\"https://cdn.jsdelivr.net/npm/essentia.js@0.1.3/dist/essentia-wasm.umd.js\",\n\t\t\t\"https://cdn.jsdelivr.net/npm/essentia.js@0.1.3/dist/essentia.js-extractor.umd.js\",\n\t\t\t\"https://raw.githack.com/MTG/essentia.js/master/examples/demos/melspectrogram-rt/melspectrogram-processor.js\",\n\t\t\t\"https://unpkg.com/ringbuf.js@0.1.0/dist/index.js\"];\n\n\t\t// inject Essentia.js code into AudioWorkletGlobalScope context, then setup audio graph\n\t\tURLFromFiles(codeForProcessorModule)\n\t\t\t.then((concatenatedCode) => {\n\t\t\t\taudioCtx.audioWorklet.addModule(concatenatedCode)\n\t\t\t\t\t.then(setupAudioGraphStream)\n\t\t\t\t\t.catch(function moduleLoadRejected(msg) {\n\t\t\t\t\t\tconsole.log(`There was a problem loading the AudioWorklet module code: \\n ${msg}`);\n\t\t\t\t\t});\n\t\t\t})\n\t\t\t.catch((msg) => {\n\t\t\t\tconsole.log(`There was a problem retrieving the AudioWorklet module code: \\n ${msg}`);\n\t\t\t})\n\t} else {\n\t\tthrow \"Mic stream not active\";\n\t}\n}\nfunction startAudioProcessingMediaElt() {\n\tif (audioCtx.state == \"closed\") {\n\t\taudioCtx = new AudioContext();\n\t}\n\telse if (audioCtx.state == \"suspended\") {\n\t\taudioCtx.resume();\n\t}\n\n\tsource = audioCtx.createMediaElementSource(player);\n\tgain = audioCtx.createGain();\n\tgain.gain.setValueAtTime(0, audioCtx.currentTime);\n\tlet codeForProcessorModule = [\"https://cdn.jsdelivr.net/npm/essentia.js@0.1.3/dist/essentia-wasm.umd.js\",\n\t\t\"https://cdn.jsdelivr.net/npm/essentia.js@0.1.3/dist/essentia.js-extractor.umd.js\",\n\t\t\"https://raw.githack.com/MTG/essentia.js/master/examples/demos/melspectrogram-rt/melspectrogram-processor.js\",\n\t\t\"https://unpkg.com/ringbuf.js@0.1.0/dist/index.js\"];\n\n\t// inject Essentia.js code into AudioWorkletGlobalScope context, then setup audio graph and start animation\n\tURLFromFiles(codeForProcessorModule)\n\t\t.then((concatenatedCode) => {\n\t\t\taudioCtx.audioWorklet.addModule(concatenatedCode)\n\t\t\t\t.then(setupAudioGraphMediaElt)\n\t\t\t\t.catch(function moduleLoadRejected(msg) {\n\t\t\t\t\tconsole.log(`There was a problem loading the AudioWorklet module code: \\n ${msg}`);\n\t\t\t\t});\n\t\t})\n\t\t.catch((msg) => {\n\t\t\tconsole.log(`There was a problem retrieving the AudioWorklet module code: \\n ${msg}`);\n\t\t})\n}\nfunction stopMicRecordStream() {\n\t// stop mic stream\n\tgumStream.getAudioTracks().forEach(function (track) {\n\t\ttrack.stop();\n\t\tgumStream.removeTrack(track);\n\t});\n\n\taudioCtx.close().then(function () {\n\t\t// disconnect nodes\n\t\tmic.disconnect();\n\t\tmelspectrogramNode.disconnect();\n\t\tgain.disconnect();\n\t\tmic = undefined;\n\t\tmelspectrogramNode = undefined;\n\t\tgain = undefined;\n\t\tconsole.log(\"Stopped recording ...\");\n\t});\n}\nfunction stopAudioProcessingMediaElt() {\n\taudioCtx.close().then(function () {\n\t\t// disconnect nodes\n\t\tsource.disconnect();\n\t\tmelspectrogramNode.disconnect();\n\t\tsource = undefined;\n\t\tmelspectrogramNode = undefined;\n\t});\n}\n\nfunction setupAudioGraphStream() {\n\t// increase buffer size to reduce audio artifacts\n\tlet sab = exports.RingBuffer.getStorageForCapacity(melNumBands * 42, Float32Array);\n\tlet rb = new exports.RingBuffer(sab, Float32Array);\n\taudioReader = new exports.AudioReader(rb);\n\n\tmelspectrogramNode = new AudioWorkletNode(audioCtx, 'melspectrogram-processor', {\n\t\tprocessorOptions: {\n\t\t\tbufferSize: bufferSize,\n\t\t\thopSize: hopSize,\n\t\t\tmelNumBands: melNumBands,\n\t\t\tsampleRate: audioCtx.sampleRate,\n\t\t}\n\t});\n\n\ttry {\n\t\tmelspectrogramNode.port.postMessage({\n\t\t\tsab: sab,\n\t\t});\n\t} catch (_) {\n\t\talert(\"No SharedArrayBuffer transfer support, try another browser.\");\n\t\trecordButton.disabled = true;\n\t\treturn;\n\t}\n\tmic.connect(melspectrogramNode);\n\tmelspectrogramNode.connect(gain);\n\tgain.connect(audioCtx.destination);\n}\n\nfunction setupAudioGraphMediaElt() {\n\t// increase buffer size in case of glitches\n\tlet sab = exports.RingBuffer.getStorageForCapacity(melNumBands * 18, Float32Array);\n\tlet rb = new exports.RingBuffer(sab, Float32Array);\n\taudioReader = new exports.AudioReader(rb);\n\tmelspectrogramNode = new AudioWorkletNode(audioCtx, 'melspectrogram-processor', {\n\t\tprocessorOptions: {\n\t\t\tbufferSize: 1024,\n\t\t\thopSize: 512,\n\t\t\tmelNumBands: melNumBands,\n\t\t\tsampleRate: audioCtx.sampleRate,\n\t\t}\n\t});\n\ttry {\n\t\tmelspectrogramNode.port.postMessage({\n\t\t\tsab: sab,\n\t\t});\n\t} catch (_) {\n\t\talert(\"No SharedArrayBuffer transfer support, try another browser.\");\n\t\treturn;\n\t}\n\t// connect source to destination for playback\n\tsource.connect(audioCtx.destination);\n\t// connect source to AudioWorklet node for feature extraction\n\tsource.connect(melspectrogramNode);\n\tmelspectrogramNode.connect(gain);\n\tgain.connect(audioCtx.destination);\n}\n\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n// Send audio interleaved audio frames between threads, wait-free.\n//\n// Those classes allow communicating between a non-real time thread (browser\n// main thread or worker) and a real-time thread (in an AudioWorkletProcessor).\n// Write and Reader cannot change role after setup, unless externally\n// synchronized.\n//\n// GC _can_ happen during the initial construction of this object when hopefully\n// no audio is being output. This depends on how implementations schedule GC\n// passes. After the setup phase no GC is triggered on either side of the queue..\n\n// Interleaved -> Planar audio buffer conversion\n//\n// `input` is an array of n*128 frames arrays, interleaved, where n is the\n// channel count.\n// output is an array of 128-frames arrays.\n//\n// This is useful to get data from a codec, the network, or anything that is\n// interleaved, into planar format, for example a Web Audio API AudioBuffer or\n// the output parameter of an AudioWorkletProcessor.\nfunction deinterleave(input, output) {\n  var channel_count = input.length / 256;\n  if (output.length != channel_count) {\n    throw \"not enough space in output arrays\";\n  }\n  for (var i = 0; i < channelCount; i++) {\n    let out_channel = output[i];\n    let interleaved_idx = i;\n    for (var j = 0; j < 128; ++j) {\n      out_channel[j] = input[interleaved_idx];\n      interleaved_idx += channel_count;\n    }\n  }\n}\n// Planar -> Interleaved audio buffer conversion\n//\n// Input is an array of `n` 128 frames Float32Array that hold the audio data.\n// output is a Float32Array that is n*128 elements long. This function is useful\n// to get data from the Web Audio API (that does planar audio), into something\n// that codec or network streaming library expect.\nfunction interleave(input, output) {\n  if (input.length * 128 != output.length) {\n    throw \"input and output of incompatible sizes\";\n  }\n  var out_idx = 0;\n  for (var i = 0; i < 128; i++) {\n    for (var channel = 0; j < output.length; j++) {\n      output[out_idx] = input[channel][i];\n      out_idx++;\n    }\n  }\n}\n\nclass AudioWriter {\n  // From a RingBuffer, build an object that can enqueue enqueue audio in a ring\n  // buffer.\n  constructor(ringbuf) {\n    if (ringbuf.type() != \"Float32Array\") {\n      throw \"This class requires a ring buffer of Float32Array\";\n    }\n    this.ringbuf = ringbuf;\n  }\n  // Enqueue a buffer of interleaved audio into the ring buffer.\n  // Returns the number of samples that have been successfuly written to the\n  // queue. `buf` is not written to during this call, so the samples that\n  // haven't been written to the queue are still available.\n  enqueue(buf) {\n    return this.ringbuf.push(buf);\n  }\n  // Query the free space in the ring buffer. This is the amount of samples that\n  // can be queued, with a guarantee of success.\n  available_write() {\n    return this.ringbuf.available_write();\n  }\n}\n\nclass AudioReader {\n  constructor(ringbuf) {\n    if (ringbuf.type() != \"Float32Array\") {\n      throw \"This class requires a ring buffer of Float32Array\";\n    }\n    this.ringbuf = ringbuf;\n  }\n  // Attempt to dequeue at most `buf.length` samples from the queue. This\n  // returns the number of samples dequeued. If greater than 0, the samples are\n  // at the beginning of `buf`\n  dequeue(buf) {\n    if (this.ringbuf.empty()) {\n      return 0;\n    }\n    return this.ringbuf.pop(buf);\n  }\n  // Query the occupied space in the queue. This is the amount of samples that\n  // can be read with a guarantee of success.\n  available_read() {\n    return this.ringbuf.available_read();\n  }\n}\n\n// Communicate parameter changes, lock free, no gc.\n//\n// between a UI thread (browser main thread or worker) and a real-time thread\n// (in an AudioWorkletProcessor). Write and Reader cannot change role after\n// setup, unless externally synchronized.\n//\n// GC can happen during the initial construction of this object when hopefully\n// no audio is being output. This depends on the implementation.\n//\n// Parameter changes are like in the VST framework: an index and a float value\n// (no restriction on the value).\n//\n// This class supports up to 256 parameters, but this is easy to extend if\n// needed.\n//\n// An element is a index, that is an unsigned byte, and a float32, which is 4\n// bytes.\n\nclass ParameterWriter {\n  // From a RingBuffer, build an object that can enqueue a parameter change in\n  // the queue.\n  constructor(ringbuf) {\n    if (ringbuf.type() != \"Uint8Array\") {\n      throw \"This class requires a ring buffer of Uint8Array\";\n    }\n    const SIZE_ELEMENT = 5;\n    this.ringbuf = ringbuf;\n    this.mem = new ArrayBuffer(SIZE_ELEMENT);\n    this.array = new Uint8Array(this.mem);\n    this.view = new DataView(this.mem);\n  }\n  // Enqueue a parameter change for parameter of index `index`, with a new value\n  // of `value`.\n  // Returns true if enqueuing suceeded, false otherwise.\n  enqueue_change(index, value) {\n    const SIZE_ELEMENT = 5;\n    this.view.setUint8(0, index);\n    this.view.setFloat32(1, value);\n    if (this.ringbuf.available_write() < SIZE_ELEMENT) {\n      return false;\n    }\n    return this.ringbuf.push(this.array) == SIZE_ELEMENT;\n  }\n}\n\nclass ParameterReader {\n  constructor(ringbuf) {\n    const SIZE_ELEMENT = 5;\n    this.ringbuf = ringbuf;\n    this.mem = new ArrayBuffer(SIZE_ELEMENT);\n    this.array = new Uint8Array(this.mem);\n    this.view = new DataView(this.mem);\n  }\n  dequeue_change(o) {\n    if (this.ringbuf.empty()) {\n      return false;\n    }\n    var rv = this.ringbuf.pop(this.array);\n    o.index = this.view.getUint8(0);\n    o.value = this.view.getFloat32(1);\n\n    return true;\n  }\n}\n\n// A Single Producer - Single Consumer thread-safe wait-free ring buffer.\n//\n// The producer and the consumer can be separate thread, but cannot change role,\n// except with external synchronization.\n\nclass RingBuffer {\n  static getStorageForCapacity(capacity, type) {\n    if (!type.BYTES_PER_ELEMENT) {\n      throw \"Pass in a ArrayBuffer subclass\";\n    }\n    var bytes = 8 + (capacity + 1) * type.BYTES_PER_ELEMENT;\n    return new SharedArrayBuffer(bytes);\n  }\n  // `sab` is a SharedArrayBuffer with a capacity calculated by calling\n  // `getStorageForCapacity` with the desired capacity.\n  constructor(sab, type) {\n    if (!ArrayBuffer.__proto__.isPrototypeOf(type) &&\n      type.BYTES_PER_ELEMENT !== undefined) {\n      throw \"Pass a concrete typed array class as second argument\";\n    }\n\n    // Maximum usable size is 1<<32 - type.BYTES_PER_ELEMENT bytes in the ring\n    // buffer for this version, easily changeable.\n    // -4 for the write ptr (uint32_t offsets)\n    // -4 for the read ptr (uint32_t offsets)\n    // capacity counts the empty slot to distinguish between full and empty.\n    this._type = type;\n    this.capacity = (sab.byteLength - 8) / type.BYTES_PER_ELEMENT;\n    this.buf = sab;\n    this.write_ptr = new Uint32Array(this.buf, 0, 1);\n    this.read_ptr = new Uint32Array(this.buf, 4, 1);\n    this.storage = new type(this.buf, 8, this.capacity);\n  }\n  // Returns the type of the underlying ArrayBuffer for this RingBuffer. This\n  // allows implementing crude type checking.\n  type() {\n    return this._type.name;\n  }\n  // Push bytes to the ring buffer. `bytes` is an typed array of the same type\n  // as passed in the ctor, to be written to the queue.\n  // Returns the number of elements written to the queue.\n  push(elements) {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    if ((wr + 1) % this._storage_capacity() == rd) {\n      // full\n      return 0;\n    }\n\n    let to_write = Math.min(this._available_write(rd, wr), elements.length);\n    let first_part = Math.min(this._storage_capacity() - wr, to_write);\n    let second_part = to_write - first_part;\n\n    this._copy(elements, 0, this.storage, wr, first_part);\n    this._copy(elements, first_part, this.storage, 0, second_part);\n\n    // publish the enqueued data to the other side\n    Atomics.store(\n      this.write_ptr,\n      0,\n      (wr + to_write) % this._storage_capacity()\n    );\n\n    return to_write;\n  }\n  // Read `elements.length` elements from the ring buffer. `elements` is a typed\n  // array of the same type as passed in the ctor.\n  // Returns the number of elements read from the queue, they are placed at the\n  // beginning of the array passed as parameter.\n  pop(elements) {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    if (wr == rd) {\n      return 0;\n    }\n\n    let to_read = Math.min(this._available_read(rd, wr), elements.length);\n\n    let first_part = Math.min(this._storage_capacity() - rd, elements.length);\n    let second_part = to_read - first_part;\n\n    this._copy(this.storage, rd, elements, 0, first_part);\n    this._copy(this.storage, 0, elements, first_part, second_part);\n\n    Atomics.store(this.read_ptr, 0, (rd + to_read) % this._storage_capacity());\n\n    return to_read;\n  }\n\n  // True if the ring buffer is empty false otherwise. This can be late on the\n  // reader side: it can return true even if something has just been pushed.\n  empty() {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    return wr == rd;\n  }\n\n  // True if the ring buffer is full, false otherwise. This can be late on the\n  // write side: it can return true when something has just been poped.\n  full() {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    return (wr + 1) % this.capacity != rd;\n  }\n\n  // The usable capacity for the ring buffer: the number of elements that can be\n  // stored.\n  capacity() {\n    return this.capacity - 1;\n  }\n\n  // Number of elements available for reading. This can be late, and report less\n  // elements that is actually in the queue, when something has just been\n  // enqueued.\n  available_read() {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n    return this._available_read(rd, wr);\n  }\n\n  // Number of elements available for writing. This can be late, and report less\n  // elemtns that is actually available for writing, when something has just\n  // been dequeued.\n  available_write() {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n    return this._available_write(rd, wr);\n  }\n\n  // private methods //\n\n  // Number of elements available for reading, given a read and write pointer..\n  _available_read(rd, wr) {\n    if (wr > rd) {\n      return wr - rd;\n    } else {\n      return wr + this._storage_capacity() - rd;\n    }\n  }\n\n  // Number of elements available from writing, given a read and write pointer.\n  _available_write(rd, wr) {\n    let rv = rd - wr - 1;\n    if (wr >= rd) {\n      rv += this._storage_capacity();\n    }\n    return rv;\n  }\n\n  // The size of the storage for elements not accounting the space for the index.\n  _storage_capacity() {\n    return this.capacity;\n  }\n\n  // Copy `size` elements from `input`, starting at offset `offset_input`, to\n  // `output`, starting at offset `offset_output`.\n  _copy(input, offset_input, output, offset_output, size) {\n    for (var i = 0; i < size; i++) {\n      output[offset_output + i] = input[offset_input + i];\n    }\n  }\n}\n\nexports.AudioReader = AudioReader;\nexports.AudioWriter = AudioWriter;\nexports.ParameterReader = ParameterReader;\nexports.ParameterWriter = ParameterWriter;\nexports.RingBuffer = RingBuffer;\nexports.deinterleave = deinterleave;\nexports.interleave = interleave;\n//sourceMappingURL=index.js.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"bundle.\" + \"6e28ccc78870e32f327a\" + \".js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/hyperstep/\";","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t271: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunk\"] = self[\"webpackChunk\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [365,996,659,732], () => (__webpack_require__(652)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","GenerateSDFMaterial","ShaderMaterial","constructor","params","super","uniforms","matrix","value","Matrix4","zValue","bvh","MeshBVHUniformStruct","vertexShader","fragmentShader","shaderStructs","shaderIntersectFunction","shaderDistanceFunction","this","setValues","RayMarchSDFMaterial","defines","MAX_STEPS","SURFACE_EPSILON","surface","sdfTex","normalStep","Vector3","projectionInverse","sdfTransformInverse","RayCastSDFMaterial","dataTex","URLFromFiles","files","promises","map","file","fetch","then","response","text","Promise","all","texts","unshift","join","blob","Blob","type","URL","createObjectURL","gpuGeneration","resolution","margin","regenerate","updateSDF","mode","bufferSize","hopSize","melNumBands","numFrames","renderer","camera","scene","gui","stats","boxHelper","audioCtx","gumStream","source","audioReader","mic","gain","melspectrogramNode","outputContainer","geometry","specTex","mesh","generateSdfPass","raymarchPass","raycastPass","bvhGenerationWorker","exports","require","inverseBoundsMatrix","THREE","fileInput","document","getElementById","recordButton","player","audioFiles","audioFile1","audioFile2","audioFile3","window","webkitURL","buttonGroup","scaledMelspectrum","rebuildGUI","destroy","GUI","generationFolder","addFolder","add","displayFolder","onChange","dim","center","quat","scale","boundingBox","getCenter","subVectors","max","min","x","y","z","compose","copy","invert","box","dispose","pxWidth","halfWidth","startTime","performance","now","texture","format","minFilter","magFilter","needsUpdate","material","updateFrom","i","setRenderTarget","render","readRenderTargetPixels","Float32Array","posAttr","attributes","position","indexAttr","index","point","normal","delta","tri","target","set","applyMatrix4","dist","closestPointToPoint","distance","faceIndex","i0","getX","i1","i2","setFromAttributeAndIndices","getNormal","image","data","dot","innerText","toFixed","onRecordClickHandler","classList","contains","remove","innerHTML","disabled","getAudioTracks","forEach","track","stop","removeTrack","close","disconnect","undefined","console","log","navigator","mediaDevices","getUserMedia","audio","video","startAudioProcessingStream","catch","message","startMicRecordStream","onPlayClickHandler","paused","state","AudioContext","resume","createMediaElementSource","createGain","setValueAtTime","currentTime","concatenatedCode","audioWorklet","addModule","setupAudioGraphMediaElt","msg","stream","active","createMediaStreamSource","setupAudioGraphStream","sab","RingBuffer","getStorageForCapacity","rb","AudioReader","AudioWorkletNode","processorOptions","sampleRate","port","postMessage","_","alert","connect","destination","antialias","setPixelRatio","devicePixelRatio","setSize","innerWidth","innerHeight","setClearColor","outputEncoding","body","appendChild","domElement","light","far","updateProjectionMatrix","axesHelper","OrbitControls","Stats","FullScreenQuad","GenerateMeshBVHWorker","GLTFLoader","setMeshoptDecoder","MeshoptDecoder","loadAsync","gltf","updateMatrixWorld","staticGen","StaticGeometryGenerator","useGroups","generate","maxLeafTris","result","navigatorCopy","webkitAudioContext","e","src","load","width","height","Uint8Array","unpackAlignment","stride","createDataTexture","addEventListener","aspect","inputElement","nodeName","id","init","update","requestAnimationFrame","tex","isData3DTexture","depth","projectionMatrixInverse","matrixWorld","premultiply","multiply","melspectrumBuffer","available_read","dequeue","Math","round","widthS","heightS","Object","defineProperty","ringbuf","buf","empty","pop","AudioWriter","enqueue","push","available_write","ParameterReader","mem","ArrayBuffer","array","view","DataView","dequeue_change","o","getUint8","getFloat32","ParameterWriter","enqueue_change","setUint8","setFloat32","static","capacity","BYTES_PER_ELEMENT","bytes","SharedArrayBuffer","__proto__","isPrototypeOf","_type","byteLength","write_ptr","Uint32Array","read_ptr","storage","name","elements","rd","Atomics","wr","_storage_capacity","to_write","_available_write","length","first_part","second_part","_copy","store","to_read","_available_read","full","rv","input","offset_input","output","offset_output","size","deinterleave","channel_count","channelCount","out_channel","interleaved_idx","j","interleave","out_idx","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","call","m","O","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","keys","every","key","splice","r","n","getter","__esModule","d","a","definition","enumerable","get","u","chunkId","obj","prop","prototype","hasOwnProperty","p","b","baseURI","self","location","href","installedChunks","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","some","chunkLoadingGlobal","bind","__webpack_exports__"],"sourceRoot":""}