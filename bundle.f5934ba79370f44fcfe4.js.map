{"version":3,"file":"bundle.f5934ba79370f44fcfe4.js","mappings":"UAAIA,E,oFCgBJ,IAAIC,EACHC,EACAC,EACAC,EACAC,EACAC,EAEGC,EACHC,EACAC,EACAC,EAEAC,EACAC,EACAC,EAIGC,EAEAC,GA1B+B,IAA9BC,EAAAA,EAAAA,qBAEJC,SAASC,KAAKC,YAAaH,EAAAA,EAAAA,yBAyB5B,IAmWII,EAEAC,EACAC,EACAC,EApWAC,EAAU,CAAC,EAGfC,OAAOC,eAAeF,EAAS,aAAc,CAAEG,OAAO,IA6UtDH,EAAQI,YA/PR,MACEC,YAAYC,GACV,GAAsB,gBAAlBA,EAAQC,OACV,KAAM,oDAERC,KAAKF,QAAUA,CACjB,CAIAG,QAAQC,GACN,OAAIF,KAAKF,QAAQK,QACR,EAEFH,KAAKF,QAAQM,IAAIF,EAC1B,CAGAG,iBACE,OAAOL,KAAKF,QAAQO,gBACtB,GA4OFb,EAAQc,YAvRR,MAGET,YAAYC,GACV,GAAsB,gBAAlBA,EAAQC,OACV,KAAM,oDAERC,KAAKF,QAAUA,CACjB,CAKAS,QAAQL,GACN,OAAOF,KAAKF,QAAQU,KAAKN,EAC3B,CAGAO,kBACE,OAAOT,KAAKF,QAAQW,iBACtB,GAoQFjB,EAAQkB,gBA7LR,MACEb,YAAYC,GAEVE,KAAKF,QAAUA,EACfE,KAAKW,IAAM,IAAIC,YAFM,GAGrBZ,KAAKa,MAAQ,IAAIC,WAAWd,KAAKW,KACjCX,KAAKe,KAAO,IAAIC,SAAShB,KAAKW,IAChC,CACAM,eAAeC,GACb,OAAIlB,KAAKF,QAAQK,UAGRH,KAAKF,QAAQM,IAAIJ,KAAKa,OAC/BK,EAAEC,MAAQnB,KAAKe,KAAKK,SAAS,GAC7BF,EAAEvB,MAAQK,KAAKe,KAAKM,WAAW,IAExB,EACT,GA6KF7B,EAAQ8B,gBAzNR,MAGEzB,YAAYC,GACV,GAAsB,cAAlBA,EAAQC,OACV,KAAM,kDAGRC,KAAKF,QAAUA,EACfE,KAAKW,IAAM,IAAIC,YAFM,GAGrBZ,KAAKa,MAAQ,IAAIC,WAAWd,KAAKW,KACjCX,KAAKe,KAAO,IAAIC,SAAShB,KAAKW,IAChC,CAIAY,eAAeJ,EAAOxB,GAIpB,OAFAK,KAAKe,KAAKS,SAAS,EAAGL,GACtBnB,KAAKe,KAAKU,WAAW,EAAG9B,KACpBK,KAAKF,QAAQW,kBAHI,OAMdT,KAAKF,QAAQU,KAAKR,KAAKa,MAChC,GAkMFrB,EAAQkC,WAtKR,MACEC,6BAA6BC,EAAU7B,GACrC,IAAKA,EAAK8B,kBACR,KAAM,iCAER,IAAIC,EAAQ,GAAKF,EAAW,GAAK7B,EAAK8B,kBACtC,OAAO,IAAIE,kBAAkBD,EAC/B,CAGAjC,YAAYmC,EAAKjC,GACf,IAAKa,YAAYqB,UAAUC,cAAcnC,SACZoC,IAA3BpC,EAAK8B,kBACL,KAAM,uDAQR7B,KAAKoC,MAAQrC,EACbC,KAAK4B,UAAYI,EAAIK,WAAa,GAAKtC,EAAK8B,kBAC5C7B,KAAKE,IAAM8B,EACXhC,KAAKsC,UAAY,IAAIC,YAAYvC,KAAKE,IAAK,EAAG,GAC9CF,KAAKwC,SAAW,IAAID,YAAYvC,KAAKE,IAAK,EAAG,GAC7CF,KAAKyC,QAAU,IAAI1C,EAAKC,KAAKE,IAAK,EAAGF,KAAK4B,SAC5C,CAGA7B,OACE,OAAOC,KAAKoC,MAAMM,IACpB,CAIAlC,KAAKmC,GACH,IAAIC,EAAKC,QAAQC,KAAK9C,KAAKwC,SAAU,GACjCO,EAAKF,QAAQC,KAAK9C,KAAKsC,UAAW,GAEtC,IAAKS,EAAK,GAAK/C,KAAKgD,qBAAuBJ,EAEzC,OAAO,EAGT,IAAIK,EAAWC,KAAKC,IAAInD,KAAKoD,iBAAiBR,EAAIG,GAAKJ,EAASU,QAC5DC,EAAaJ,KAAKC,IAAInD,KAAKgD,oBAAsBD,EAAIE,GACrDM,EAAcN,EAAWK,EAY7B,OAVAtD,KAAKwD,MAAMb,EAAU,EAAG3C,KAAKyC,QAASM,EAAIO,GAC1CtD,KAAKwD,MAAMb,EAAUW,EAAYtD,KAAKyC,QAAS,EAAGc,GAGlDV,QAAQY,MACNzD,KAAKsC,UACL,GACCS,EAAKE,GAAYjD,KAAKgD,qBAGlBC,CACT,CAKA7C,IAAIuC,GACF,IAAIC,EAAKC,QAAQC,KAAK9C,KAAKwC,SAAU,GACjCO,EAAKF,QAAQC,KAAK9C,KAAKsC,UAAW,GAEtC,GAAIS,GAAMH,EACR,OAAO,EAGT,IAAIc,EAAUR,KAAKC,IAAInD,KAAK2D,gBAAgBf,EAAIG,GAAKJ,EAASU,QAE1DC,EAAaJ,KAAKC,IAAInD,KAAKgD,oBAAsBJ,EAAID,EAASU,QAC9DE,EAAcG,EAAUJ,EAO5B,OALAtD,KAAKwD,MAAMxD,KAAKyC,QAASG,EAAID,EAAU,EAAGW,GAC1CtD,KAAKwD,MAAMxD,KAAKyC,QAAS,EAAGE,EAAUW,EAAYC,GAElDV,QAAQY,MAAMzD,KAAKwC,SAAU,GAAII,EAAKc,GAAW1D,KAAKgD,qBAE/CU,CACT,CAIAvD,QACE,IAAIyC,EAAKC,QAAQC,KAAK9C,KAAKwC,SAAU,GAGrC,OAFSK,QAAQC,KAAK9C,KAAKsC,UAAW,IAEzBM,CACf,CAIAgB,OACE,IAAIhB,EAAKC,QAAQC,KAAK9C,KAAKwC,SAAU,GAGrC,OAFSK,QAAQC,KAAK9C,KAAKsC,UAAW,GAEzB,GAAKtC,KAAK4B,UAAYgB,CACrC,CAIAhB,WACE,OAAO5B,KAAK4B,SAAW,CACzB,CAKAvB,iBACE,IAAIuC,EAAKC,QAAQC,KAAK9C,KAAKwC,SAAU,GACjCO,EAAKF,QAAQC,KAAK9C,KAAKsC,UAAW,GACtC,OAAOtC,KAAK2D,gBAAgBf,EAAIG,EAClC,CAKAtC,kBACE,IAAImC,EAAKC,QAAQC,KAAK9C,KAAKwC,SAAU,GACjCO,EAAKF,QAAQC,KAAK9C,KAAKsC,UAAW,GACtC,OAAOtC,KAAKoD,iBAAiBR,EAAIG,EACnC,CAKAY,gBAAgBf,EAAIG,GAClB,OAAIA,EAAKH,EACAG,EAAKH,EAELG,EAAK/C,KAAKgD,oBAAsBJ,CAE3C,CAGAQ,iBAAiBR,EAAIG,GACnB,IAAIc,EAAKjB,EAAKG,EAAK,EAInB,OAHIA,GAAMH,IACRiB,GAAM7D,KAAKgD,qBAENa,CACT,CAGAb,oBACE,OAAOhD,KAAK4B,QACd,CAIA4B,MAAMM,EAAOC,EAAcC,EAAQC,EAAeC,GAChD,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAMC,IACxBH,EAAOC,EAAgBE,GAAKL,EAAMC,EAAeI,EAErD,GAQF3E,EAAQ4E,aA5TR,SAAsBN,EAAOE,GAC3B,IAAIK,EAAgBP,EAAMT,OAAS,IACnC,GAAIW,EAAOX,QAAUgB,EACnB,KAAM,oCAER,IAAK,IAAIF,EAAI,EAAGA,EAAIG,aAAcH,IAAK,CACrC,IAAII,EAAcP,EAAOG,GACrBK,EAAkBL,EACtB,IAAK,IAAIM,EAAI,EAAGA,EAAI,MAAOA,EACzBF,EAAYE,GAAKX,EAAMU,GACvBA,GAAmBH,CAEvB,CACF,EAgTA7E,EAAQkF,WAzSR,SAAoBZ,EAAOE,GACzB,GAAmB,IAAfF,EAAMT,QAAgBW,EAAOX,OAC/B,KAAM,yCAGR,IADA,IAAIsB,EAAU,EACLR,EAAI,EAAGA,EAAI,IAAKA,IACvB,KAAsBM,EAAIT,EAAOX,OAAQoB,IACvCT,EAAOW,GAAWb,EADD,GACgBK,GACjCQ,GAGN,EAiSA,IACG7F,EAAe8F,OAAO9F,cAAgB8F,OAAOC,mBAC7C9F,EAAW,IAAID,CAGlB,CAFE,MAAOgG,GACN,KAAM,uCAAyCA,EAAEC,OACpD,CASA,MAAMC,EAAO,CACTC,OAAQhG,SAASiG,cAAc,UAC/BC,kBAAmB,IACfC,kBACA,OAAOpF,KAAKqF,YAAYrF,KAAKiF,OAAOK,KACxC,EACIC,kBACA,OAAOvF,KAAKwF,aAAaxF,KAAKiF,OAAOQ,MACzC,EACAJ,YAAa,IACbG,aAAc,IACdE,QAAQ,EACRC,OAAQ,GACRC,OAAQ,EACRC,cAAe,GACfC,KAAM,WACF9F,KAAKiF,OAAOK,MAAQtF,KAAKmF,kBACzBnF,KAAKiF,OAAOQ,OAzXF,GA0XVzF,KAAKiF,OAAOc,MAAMT,MAAS,GAAEtF,KAAKqF,gBAClCrF,KAAKiF,OAAOc,MAAMN,OAAU,GAAEzF,KAAKwF,iBACnCxF,KAAKiF,OAAOc,MAAMC,gBAAkB,cACpChG,KAAKiG,IAAMjG,KAAKiF,OAAOiB,WAAW,KACtC,EACAC,WAAY,WACRnG,KAAK4F,OAAS,EACd5F,KAAK0F,QAAS,EACd1F,KAAKiF,OAAOK,MAAQtF,KAAKmF,kBAEzB,IAAIiB,EAAkBpG,KAAKiG,IAAII,aAAa,EAAG,EAAGrG,KAAKiF,OAAOK,MAAOtF,KAAKiF,OAAOQ,QAC7Ea,EAAOF,EAAgBE,KAC3BA,EAAOA,EAAKC,KAAK,GACjBvG,KAAKiG,IAAIO,aAAaJ,EAAiB,EAAG,GAE1CpG,KAAK6F,cAAgB,EACzB,GA+GJ,IAAIY,EAEAC,EA5GQzH,SAAS0H,eAAe,WACvB3B,EAAKW,OACLX,EAAKW,OAWGX,EAAKQ,aAyH1B,IAAIoB,EAAgBC,eACe1E,IAA/ByE,EAAcE,eACjBF,EAAcE,aAAe,CAAC,GAO/B,MAAMC,EAAY9H,SAAS0H,eAAe,iBACpCK,EAAe/H,SAAS0H,eAAe,gBAuR7C,SAASM,IAYRhJ,EAAOiJ,OAAStC,OAAOuC,WAAavC,OAAOwC,YAC3CnJ,EAAOoJ,yBAEPlJ,EAASmJ,QAAS1C,OAAOuC,WAAYvC,OAAOwC,aAE5CG,GAED,CAEA,SAASC,EAAcC,GAEtB/I,EAAQgJ,EAAKD,EAAME,QAAU/C,OAAOuC,WAAc,EAAI,EACtDzI,EAAQkJ,GAAOH,EAAMI,QAAUjD,OAAOwC,YAAe,EAAI,CAE1D,CAwBA,SAASU,EAAoBxC,EAAOG,EAAQsC,GAC3C,MAAMC,EAAI,IAAIlH,WAAYwE,EAAQG,EAASsC,EAAQ,GACnD,IAAIE,EAAS,EAEb,IAAM,IAAIC,EAAI,EAAGA,EAAIH,EAAOG,IAC1B,IAAM,IAAIN,EAAI,EAAGA,EAAInC,EAAQmC,IAC3B,IAAM,IAAIF,EAAI,EAAGA,EAAIpC,EAAOoC,IAC1BM,EAAEC,EAAS,GAAMP,EAAIpC,EAAS,IAC9B0C,EAAEC,EAAS,GAAML,EAAInC,EAAU,IAC/BuC,EAAEC,EAAS,GAAMC,EAAIH,EAAS,IAE9BC,EAAEC,EAAS,GAAK,IAChBA,GAAU,EAIhB,MAAME,EAAU,IAAIC,EAAAA,IAAqBJ,EAAG1C,EAAOG,EAAQsC,GAQ3D,OAPAI,EAAQE,OAASD,EAAAA,IAIjBD,EAAQG,gBAAkB,EAC1BH,EAAQI,aAAc,EAEfJ,CACR,CACA,SAASK,EAAkBlD,EAAOG,GAEjC,MAAMuC,EAAI,IAAIS,aAAcnD,EAAQG,EAAS,GAE7C,IAAIwC,EAAS,EACb,IAAM,IAAIL,EAAI,EAAGA,EAAInC,EAAQmC,IAC3B,IAAM,IAAIF,EAAI,EAAGA,EAAIpC,EAAOoC,IAC1BM,EAAEC,EAAS,GAAK,EAChBD,EAAEC,EAAS,GAAK,EAChBD,EAAEC,EAAS,GAAK,EAChBD,EAAEC,EAAS,GAAK,EAChBA,GAAU,EAGd,MAAME,EAAU,IAAIC,EAAAA,IAAmBJ,EAAG1C,EAAOG,GAQjD,OAPA0C,EAAQE,OAASD,EAAAA,IACjBD,EAAQpI,KAAOqI,EAAAA,IACfD,EAAQO,UAAYN,EAAAA,IACpBD,EAAQQ,UAAYP,EAAAA,IACpBD,EAAQG,gBAAkB,EAC1BH,EAAQI,aAAc,EAEfJ,CACR,CAwEA,SAASS,EAAuBtC,GAC/B,MAAM0B,EAAI,IAAIS,aAAgC,EAAlBnC,EAAKuC,UAAiB,GAClD,IAAIZ,EAAS,EACb,MAAMa,EAAU,CAACxC,EAAKyC,UAAWzC,EAAK0C,SAAU1C,EAAK2C,QAAS3C,EAAK4C,WACnE,IAAM,IAAIzE,EAAI,EAAGA,EAAI,EAAGA,IACtB,IAAM,IAAI0E,EAAI,EAAGA,EAAI7C,EAAKuC,UAAWM,IACnCnB,EAAEC,EAAS,GAAKa,EAAQrE,GAAG0E,GAAGzB,EAC9BM,EAAEC,EAAS,GAAKa,EAAQrE,GAAG0E,GAAGvB,EAC9BI,EAAEC,EAAS,GAAKa,EAAQrE,GAAG0E,GAAGjB,EAC9BF,EAAEC,EAAS,GAAK,EAChBA,GAAU,EAGd,MAAME,EAAU,IAAIC,EAAAA,IAAmBJ,EAAG1B,EAAKuC,UAAW,GAO1D,OANAV,EAAQpI,KAAOqI,EAAAA,IACfD,EAAQE,OAASD,EAAAA,IACjBD,EAAQO,UAAYN,EAAAA,IACpBD,EAAQQ,UAAYP,EAAAA,IACpBD,EAAQG,gBAAkB,EAC1BH,EAAQI,aAAc,EACfJ,CACR,CAoEA,SAASZ,IACRpJ,EAASoJ,OAAOrJ,EAAOD,EACxB,CAoDA,SAASmL,IACUpC,EAAaqC,UAAUC,SAAS,aAM5CC,uBAJAvC,EAAawC,aAAa,YAAY,GAS7C,WACG,IAAI3C,UAAUC,aAAa2C,aAQvB,KAAM,2DAPNC,QAAQC,IAAI,yBACZ9C,UAAUC,aAAa2C,aAAa,CAAEG,OAAO,EAAMC,OAAO,IACzDC,KAAKC,GACLC,OAAM,SAASjF,GACR,KAAM,iCAAmCA,CACjD,GAIP,CAlBOkF,GAIP,CAgBA,SAASF,EAAqBG,GAE3B,GADA9K,EAAY8K,GACR9K,EAAU+K,OAqCV,KAAM,wBAlCgB,UAAlBpL,EAASqL,MACTrL,EAAW,IAAID,EAEQ,aAAlBC,EAASqL,OACdrL,EAASsL,SAGbhL,EAAMN,EAASuL,wBAAwBlL,GACvCE,EAAOP,EAASwL,aAChBjL,EAAKA,KAAKkL,eAAe,EAAGzL,EAAS0L,aA5D5C,SAAsBC,GACrB,MAAMC,EA8D6B,CAAC,2EAC9B,mFACA,8GACA,oDAhEDC,KAAKC,GAASC,MAAMD,GAChBf,MAAMiB,GAAaA,EAASC,WACrC,OAAOC,QACFC,IAAIP,GACJb,MAAMqB,IACHA,EAAMC,QAAQ,qBACd,MAAMJ,EAAOG,EAAME,KAAK,IAClBC,EAAO,IAAIC,KAAK,CAACP,GAAO,CAACjL,KAAM,oBAErC,OAAOyL,IAAIC,gBAAgBH,EAAK,GAEzC,CAwDOI,GACC5B,MAAM6B,IACH5M,EAAS6M,aAAaC,UAAUF,GAC/B7B,KAAKgC,GACL9B,OAAO,SAA4B+B,GAChCrC,QAAQC,IAAK,gEAA+DoC,IAChF,GAAE,IAEL/B,OAAO+B,IACJrC,QAAQC,IAAK,mEAAkEoC,IAAM,IAGzF/E,EAAaqC,UAAU2C,IAAI,aAC3BhF,EAAaiF,UAAY,OACzBjF,EAAawC,aAAa,YAAY,EAI7C,CAEA,SAASsC,IAEN,IAAI9J,EAAMxC,EAAQkC,WAAWwK,sBAAsBC,KAAgB1D,cAC/D2D,EAAK,IAAI5M,EAAQkC,WAAWM,EAAKyG,cACrC/B,EAAc,IAAIlH,EAAQI,YAAYwM,GAEtC7M,EAAqB,IAAI8M,iBAAiBtN,EAAU,2BAA4B,CAC5EuN,iBAAkB,CACdC,WA9rCM,KA+rCNC,QA9rCG,IA+rCHL,YA9rCO,GA+rCPM,WAAY1N,EAAS0N,cAI7B,IACIlN,EAAmBmN,KAAKC,YAAY,CAChC3K,IAAKA,GAMb,CAJE,MAAM4K,GAGJ,OAFAC,MAAM,oEACN7F,EAAawC,aAAa,YAAY,EAE1C,CAIAnK,EAAIyN,QAAQvN,GACZA,EAAmBuN,QAAQxN,GAC3BA,EAAKwN,QAAQ/N,EAASgO,aAEtBC,sBAAsBC,EACzB,CAEA,IAAIC,EACAC,EAEJ,SAASF,EAAmBG,QACFjL,IAAnB+K,IACAA,EAAiBE,GACrBD,EAAUC,EAAYF,EACtBzG,EAAkBuG,sBAAsBC,GAExC,IAAII,EAAoB,IAAI5E,aA/tCb,IAguCX/B,EAAYrG,kBAhuCD,IAkuCI,IADFqG,EAAYzG,QAAQoN,IAGLA,EAAkBzC,KAAIlD,GAAKxE,KAAKoK,MAAQ,KAAF5F,IAKzE,CAtsBA6F,iBAAiB,UAAU,KAAMC,OAGfC,EAHwB1G,GAKrB2G,EAAAA,EAAAA,IAAkBD,EAAa/C,MAAM,IAExDZ,MACE6D,GAYJC,eAA+BC,GAC9B,MAAMC,QAA2BC,EAAAA,EAAAA,IAAoBF,GACrD,OAAOG,EAAAA,EAAAA,KAAUC,EAAAA,EAAAA,IAAeH,EAAoB,CAClDrB,WArDiB,KAsDjByB,UApDqB,IAqDrBC,MAtDmB,IAwDnBC,KAAM,KACNC,KAAM,KAET,CAtBuBC,CAAgBX,KACrC7D,MACEyE,GA6WJ,SAAqCjI,EAAMhB,EAAOG,GACjD,MAAMuC,EAAI,IAAIS,aAAcnD,EAAQG,EAAS,GAC7C,IAAIwC,EAAS,EACb,IAAM,IAAIL,EAAI,EAAGA,EAAInC,EAAQmC,IAC3B,IAAM,IAAIF,EAAI,EAAGA,EAAIpC,EAAOoC,IAC1BM,EAAEC,EAAS,GAAK3B,EAAKoB,GAAGE,GACxBI,EAAEC,EAAS,GAAK,EAChBD,EAAEC,EAAS,GAAK,EAChBD,EAAEC,EAAS,GAAK,EAChBA,GAAU,EAKd,IAFA,IAAIuG,GAAM,IACNrL,EAAMsL,IACFtK,EAAI,EAAGA,EAAI6D,EAAE3E,OAAQc,IAAU6D,EAAE7D,GAAKqK,IAAKA,EAAMxG,EAAE7D,IAC3D,IAAQA,EAAI,EAAGA,EAAI6D,EAAE3E,OAAQc,IAAU6D,EAAE7D,GAAKhB,IAAKA,EAAM6E,EAAE7D,IAI3D,IADA8D,EAAS,EACHA,EAAS3C,EAAQG,EAAS,GAC9BuC,EAAEC,IAAWD,EAAEC,GAAU9E,IAAQqL,EAAMrL,GACvC8E,GAAS,EAEX,MAAME,EAAU,IAAIC,EAAAA,IAAmBJ,EAAG1C,EAAOG,GAQjD,OAPA0C,EAAQE,OAASD,EAAAA,IACjBD,EAAQpI,KAAOqI,EAAAA,IACfD,EAAQO,UAAYN,EAAAA,IACpBD,EAAQQ,UAAYP,EAAAA,IACpBD,EAAQG,gBAAkB,EAC1BH,EAAQI,aAAc,EAEfJ,CACR,CA5YYuG,CAA4BH,EAASA,EAAQlL,OAxCnC,OA2CpByG,MACE6E,IAAiB,OAkgBGxG,EAlgBmBwG,EAmgBzCnQ,EAAeoQ,SAAUhE,IAAMzC,EAC/B3J,EAAeoQ,SAAUC,UACzBpQ,EAAWmQ,SAAUE,SAAmB,SAAS,MAAI3G,OACrD1J,EAAWmQ,SAAUC,UAJvB,IAAwB1G,CAlgB+B,IAZvD,IAAkBsF,CAHiD,IAgLnE,WACCvP,EAAQ,IAAIkK,EAAAA,IAGZjK,EAAW,IAAIiK,EAAAA,IAAoB,CAAC2G,WAAW,IAC/C5Q,EAAS6Q,cAAepK,OAAOqK,kBAC/B9Q,EAASmJ,QAAS1C,OAAOuC,WAAYvC,OAAOwC,aAK5C,MAAMF,EAAStC,OAAOuC,WAAavC,OAAOwC,YAC1CnJ,EAAS,IAAImK,EAAAA,IAAyB,GAAIlB,EAAQ,IAAM,KAMxDjJ,EAAOiR,SAASC,IAAK,EAAG,EAAG,IAC1BjR,EAAM8N,IAAI/N,GAGXG,EAAW,IAAIgR,EAAAA,EAAenR,EAAQE,EAASkR,YAC/CjR,EAASmP,iBAAkB,SAAUhG,GACrCnJ,EAASkR,QAAU,GACnBlR,EAASmR,QAAU,GACnBnR,EAASoR,WAAY,EACrBpR,EAASqR,SAGT,IAAIC,EAAY,IAAItH,EAAAA,IAAoB,EAAG,GACvCuH,EAAY,IAAIvH,EAAAA,IAAwB,CAAEwC,IAAKpC,EArPtC,EACA,GAoPuEoH,KAAMxH,EAAAA,MAC1F5J,EAAiB,IAAI4J,EAAAA,IAAWsH,EAAWC,GAC3CnR,EAAgB0Q,SAASC,KAAM,EAAG,GAAI,GACtCjR,EAAM8N,IAAIxN,GAGV,MAAMqR,EAAiB,IAAIzH,EAAAA,IAxPZ,EACA,EACA,GAuPfzJ,EAAQ,IAAIyJ,EAAAA,IAEZ,MACM0H,EA4PP,SAAuBC,GAEtB,MAAMC,EAAQ,IAAI5H,EAAAA,IAAwB,CACxC,IAAIA,EAAAA,IAAe,EAAG,GAAM,IAC5B,IAAIA,EAAAA,IAAc,EAAG,GAAO,KAC5B,IAAIA,EAAAA,IAAe,EAAG,EAAM,GAC5B,IAAIA,EAAAA,IAAe,EAAG,EAAK,KAC3B,IAAIA,EAAAA,IAAe,EAAG,EAAK,MAEvB6H,EAAUD,EAAME,gBAjfE,GAkfjBC,EAAWH,EAAMI,oBAlfA,GAkfgC,GASxD,OAPAvR,EAAc,CACZkK,UAAYkH,EACZjH,SAAUmH,EAASnH,SACnBC,QAAUkH,EAASlH,QACnBC,UAAYiH,EAASjH,UACrBL,UAzfsB,GA2fjBmH,CACR,CAjReK,GACOC,UAAW,GAC1BC,GAAW,IAAInI,EAAAA,KAAuBoI,cAAeV,GACrDlB,EAAW,IAAIxG,EAAAA,IAAyB,CAAEqI,MAAO,WAGvD7R,EAAY,IAAIwJ,EAAAA,IAAYmI,EAAU3B,GACtChQ,EAAU8R,kBAAmB,EAC7BxS,EAAM8N,IAAIpN,GAEV,MAAM+R,EAAkB,CACtB,aAAgB,CAAEhR,MAAO,IAAIyI,EAAAA,IAtQhB,EACA,EACA,IAqQb,OAAU,CAAEzI,MAAOmI,EA1QR,EACA,EACA,IAyQX,YAAe,CAAEnI,MAAO,IAAIyI,EAAAA,IA3QjB,EACA,EACA,IA0QX,SAAY,CAAEzI,MAAO,IAAIyI,EAAAA,KACzB,SAAY,CAAEzI,MAAO,IAAIyI,EAAAA,KACzB,SAAY,CAAEzI,MAAO,IACrB,SAAY,CAAEA,MAAO6I,EAjQL,IAiQmCoI,OACnD,WAAc,CAAEjR,MAAOiJ,EAAuB/J,IAC9C,KAAQ,CAACc,MAAOhB,EAAMkS,mBAGlBC,EAAiB,IAAI1I,EAAAA,IAAqB,CAC9C0G,SAAU6B,EACVI,aA/MoC,mdAgNpCC,eApMsC,wjHAqMtCpB,KAAMxH,EAAAA,IACN6I,aAAa,IAGfxS,EAAa,IAAI2J,EAAAA,IAAYyH,EAAgBiB,GAC7CrS,EAAWiS,kBAAmB,EAC9BjS,EAAW8R,SAASW,qBAEnBzS,EAAWmQ,SAAUE,SAAmB,SAAS,MAAIrQ,EAAW8R,SAASY,YAAYhO,IACrF1E,EAAWmQ,SAAUE,SAAmB,SAAS,MAAIrQ,EAAW8R,SAASY,YAAY3C,IACtFtQ,EAAM8N,IAAIvN,GAEVC,EAAU,IAAI0J,EAAAA,IAEdxD,OAAO2I,iBAAiB,cAAe/F,GAEvC,MAAM4J,EAAW,IAAIhJ,EAAAA,IAAoB,GAAI,IACvCiJ,EAAW,IAAIjJ,EAAAA,IAAwB,CAACkJ,SAAS,IACvD/S,EAAY,IAAI6J,EAAAA,IAAWgJ,EAAUC,GACrC9S,EAAUgT,SAAS7J,GAAK,GAAMxE,KAAKsO,GACnCtT,EAAM8N,IAAIzN,GACVA,EAAUmE,KAAO,QAEjBpE,EAAY,IAAI8J,EAAAA,IAsCjB,SAAqBlK,GACpB,MAAMuT,EAAa,IAAIrJ,EAAAA,IAAkB,GAAI,IAC7ClK,EAAM8N,IAAKyF,GACXpT,GAAQqT,EAAAA,EAAAA,KACRzS,SAASC,KAAKC,YAAYd,EAAMsT,KAChC,MAAMC,EAAa,IAAIxJ,EAAAA,IAAkB,GACzClK,EAAM8N,IAAK4F,EACZ,CA1CCC,CAAW3T,GACXqJ,IACAtI,SAASsO,iBAAkB,cAAe/F,GAC1C5C,OAAO2I,iBAAkB,SAAUtG,GACnCD,EAAauG,iBAAiB,QAASnE,EACxC,CArGAtD,GAgJA,SAASgM,IACR9E,sBAAsB8E,GAJrBrT,EAAWmQ,SAAUE,SAAe,KAAS,MAAInQ,EAAMkS,iBACvDpS,EAAWmQ,SAAUE,SAAqB,WAAS,MAiLrD,SAAyBiD,EAAYhC,GAEpC,MAAMiC,EAAYD,EAAWxB,SAAS0B,WAAW/C,SAASrO,MAGpDkI,EAAYmJ,MAngBM,GAogBxB,IAAIC,EAAK,EACT,IAAK,IAAIhO,EAAI,EAAGA,EArgBQ,EAqgBSA,IAE7B4E,EAAU5E,GADJ4L,GAAL5L,EACc,IAAIiE,EAAAA,IACjB4J,EAAUG,EAAK,GACfH,EAAUG,EAAK,GAAKjP,KAAKkP,IAAIlP,KAAKmP,IAAI1T,EAAMkS,mBAC5CmB,EAAUG,EAAK,IAGF,IAAI/J,EAAAA,IACjB4J,EAAUG,EAAK,GACfH,EAAUG,EAAK,GACfH,EAAUG,EAAK,IAEnBA,GAAM,EAGR,MAAMnC,EAAQ,IAAI5H,EAAAA,IAAuBW,GACnCkH,EAAUD,EAAME,gBAthBE,GAuhBjBC,EAAWH,EAAMI,oBAvhBA,GAuhBgC,GAWxD,OARAvR,EAAc,CACZkK,UAAYkH,EACZjH,SAAUmH,EAASnH,SACnBC,QAAUkH,EAASlH,QACnBC,UAAYiH,EAASjH,UACrBL,UA/hBsB,GAkiBjBD,EAAuB/J,EAC/B,CAtN0DyT,CAAgB1T,GAKzEP,EAAMoR,SAENlI,GACD,CArJAuK,E,uFCtvBIS,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBtQ,IAAjBuQ,EACH,OAAOA,EAAalT,QAGrB,IAAImT,EAASJ,EAAyBE,GAAY,CACjDG,GAAIH,EACJI,QAAQ,EACRrT,QAAS,CAAC,GAUX,OANAsT,EAAoBL,GAAUM,KAAKJ,EAAOnT,QAASmT,EAAQA,EAAOnT,QAASgT,GAG3EG,EAAOE,QAAS,EAGTF,EAAOnT,OACf,CAGAgT,EAAoBQ,EAAIF,EC5BxBN,EAAoBS,KAAO,WAC1B,MAAM,IAAIC,MAAM,iCACjB,ECFAV,EAAoBW,KAAO,CAAC,EJAxBnV,EAAW,GACfwU,EAAoBY,EAAI,CAACC,EAAQC,EAAUC,EAAIC,KAC9C,IAAGF,EAAH,CAMA,IAAIG,EAAehF,IACnB,IAAStK,EAAI,EAAGA,EAAInG,EAASqF,OAAQc,IAAK,CAGzC,IAFA,IAAKmP,EAAUC,EAAIC,GAAYxV,EAASmG,GACpCuP,GAAY,EACPjP,EAAI,EAAGA,EAAI6O,EAASjQ,OAAQoB,MACpB,EAAX+O,GAAsBC,GAAgBD,IAAa/T,OAAOkU,KAAKnB,EAAoBY,GAAGQ,OAAOC,GAASrB,EAAoBY,EAAES,GAAKP,EAAS7O,MAC9I6O,EAASQ,OAAOrP,IAAK,IAErBiP,GAAY,EACTF,EAAWC,IAAcA,EAAeD,IAG7C,GAAGE,EAAW,CACb1V,EAAS8V,OAAO3P,IAAK,GACrB,IAAI4P,EAAIR,SACEpR,IAAN4R,IAAiBV,EAASU,EAC/B,CACD,CACA,OAAOV,CAnBP,CAJCG,EAAWA,GAAY,EACvB,IAAI,IAAIrP,EAAInG,EAASqF,OAAQc,EAAI,GAAKnG,EAASmG,EAAI,GAAG,GAAKqP,EAAUrP,IAAKnG,EAASmG,GAAKnG,EAASmG,EAAI,GACrGnG,EAASmG,GAAK,CAACmP,EAAUC,EAAIC,EAqBjB,EKzBdhB,EAAoBxK,EAAI,CAACxI,EAASwU,KACjC,IAAI,IAAIH,KAAOG,EACXxB,EAAoBtR,EAAE8S,EAAYH,KAASrB,EAAoBtR,EAAE1B,EAASqU,IAC5EpU,OAAOC,eAAeF,EAASqU,EAAK,CAAEI,YAAY,EAAMC,IAAKF,EAAWH,IAE1E,ECNDrB,EAAoB2B,EAAI,WACvB,GAA0B,iBAAfC,WAAyB,OAAOA,WAC3C,IACC,OAAOpU,MAAQ,IAAIqU,SAAS,cAAb,EAGhB,CAFE,MAAOvP,GACR,GAAsB,iBAAXF,OAAqB,OAAOA,MACxC,CACA,CAPuB,GCAxB4N,EAAoBtR,EAAI,CAACoT,EAAKC,IAAU9U,OAAO+U,UAAUC,eAAe1B,KAAKuB,EAAKC,GCClF/B,EAAoBuB,EAAKvU,IACH,oBAAXkV,QAA0BA,OAAOC,aAC1ClV,OAAOC,eAAeF,EAASkV,OAAOC,YAAa,CAAEhV,MAAO,WAE7DF,OAAOC,eAAeF,EAAS,aAAc,CAAEG,OAAO,GAAO,ECL9D6S,EAAoBoC,IAAOjC,IAC1BA,EAAOkC,MAAQ,GACVlC,EAAOmC,WAAUnC,EAAOmC,SAAW,IACjCnC,G,MCER,IAAIoC,EAAkB,CACrB,IAAK,GAaNvC,EAAoBY,EAAE3O,EAAKuQ,GAA0C,IAA7BD,EAAgBC,GAGxD,IAAIC,EAAuB,CAACC,EAA4B5O,KACvD,IAGImM,EAAUuC,GAHT1B,EAAU6B,EAAaC,GAAW9O,EAGhBnC,EAAI,EAC3B,GAAGmP,EAAS+B,MAAMzC,GAAgC,IAAxBmC,EAAgBnC,KAAa,CACtD,IAAIH,KAAY0C,EACZ3C,EAAoBtR,EAAEiU,EAAa1C,KACrCD,EAAoBQ,EAAEP,GAAY0C,EAAY1C,IAGhD,GAAG2C,EAAS,IAAI/B,EAAS+B,EAAQ5C,EAClC,CAEA,IADG0C,GAA4BA,EAA2B5O,GACrDnC,EAAImP,EAASjQ,OAAQc,IACzB6Q,EAAU1B,EAASnP,GAChBqO,EAAoBtR,EAAE6T,EAAiBC,IAAYD,EAAgBC,IACrED,EAAgBC,GAAS,KAE1BD,EAAgBC,GAAW,EAE5B,OAAOxC,EAAoBY,EAAEC,EAAO,EAGjCiC,EAAqBC,KAAmB,aAAIA,KAAmB,cAAK,GACxED,EAAmBE,QAAQP,EAAqBQ,KAAK,KAAM,IAC3DH,EAAmB9U,KAAOyU,EAAqBQ,KAAK,KAAMH,EAAmB9U,KAAKiV,KAAKH,G,KC7CvF,IAAII,EAAsBlD,EAAoBY,OAAEjR,EAAW,CAAC,IAAI,GAAG,MAAM,IAAOqQ,EAAoB,OACpGkD,EAAsBlD,EAAoBY,EAAEsC,E","sources":["webpack:///webpack/runtime/chunk loaded","webpack:///./src/automaton/script.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/amd define","webpack:///webpack/runtime/amd options","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/runtime/node module decorator","webpack:///webpack/runtime/jsonp chunk loading","webpack:///webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","import '../style.css';\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport Stats from 'three/examples/jsm/libs/stats.module';\nimport WebGL from 'three/examples/jsm/capabilities/WebGL.js';\nimport {loadAudioFromFile, resampleAndMakeMono, melSpectrogram, powerToDb} from '@magenta/music/esm/core/audio_utils';\nimport { Texture, Vector3 } from 'three';\n// import msp from './audio-processors/melspectrogram-processor.js?raw'\n\n// console.log(msp);\nif ( WebGL.isWebGL2Available() === false ) {\n \n document.body.appendChild( WebGL.getWebGL2ErrorMessage() );\n \n}\n \nlet camera,\n scene,\n renderer,\n controls,\n stats,\n raycaster\n \nlet planeMesh,\n debugPlaneMesh,\n volumeMesh,\n pointer,\n specTexture,\n clock,\n curveMesh,\n curve_data\n \nlet analyser\n \nlet AudioContext;\n// global var for web audio API AudioContext\nlet audioCtx;\nlet bufferSize = 1024;\nlet hopSize = 512;\nlet melNumBands = 96;\nlet exports = {};\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n// Send audio interleaved audio frames between threads, wait-free.\n//\n// Those classes allow communicating between a non-real time thread (browser\n// main thread or worker) and a real-time thread (in an AudioWorkletProcessor).\n// Write and Reader cannot change role after setup, unless externally\n// synchronized.\n//\n// GC _can_ happen during the initial construction of this object when hopefully\n// no audio is being output. This depends on how implementations schedule GC\n// passes. After the setup phase no GC is triggered on either side of the queue..\n\n// Interleaved -> Planar audio buffer conversion\n//\n// `input` is an array of n*128 frames arrays, interleaved, where n is the\n// channel count.\n// output is an array of 128-frames arrays.\n//\n// This is useful to get data from a codec, the network, or anything that is\n// interleaved, into planar format, for example a Web Audio API AudioBuffer or\n// the output parameter of an AudioWorkletProcessor.\nfunction deinterleave(input, output) {\n  var channel_count = input.length / 256;\n  if (output.length != channel_count) {\n    throw \"not enough space in output arrays\";\n  }\n  for (var i = 0; i < channelCount; i++) {\n    let out_channel = output[i];\n    let interleaved_idx = i;\n    for (var j = 0; j < 128; ++j) {\n      out_channel[j] = input[interleaved_idx];\n      interleaved_idx += channel_count;\n    }\n  }\n}\n// Planar -> Interleaved audio buffer conversion\n//\n// Input is an array of `n` 128 frames Float32Array that hold the audio data.\n// output is a Float32Array that is n*128 elements long. This function is useful\n// to get data from the Web Audio API (that does planar audio), into something\n// that codec or network streaming library expect.\nfunction interleave(input, output) {\n  if (input.length * 128 != output.length) {\n    throw \"input and output of incompatible sizes\";\n  }\n  var out_idx = 0;\n  for (var i = 0; i < 128; i++) {\n    for (var channel = 0; j < output.length; j++) {\n      output[out_idx] = input[channel][i];\n      out_idx++;\n    }\n  }\n}\n\nclass AudioWriter {\n  // From a RingBuffer, build an object that can enqueue enqueue audio in a ring\n  // buffer.\n  constructor(ringbuf) {\n    if (ringbuf.type() != \"Float32Array\") {\n      throw \"This class requires a ring buffer of Float32Array\";\n    }\n    this.ringbuf = ringbuf;\n  }\n  // Enqueue a buffer of interleaved audio into the ring buffer.\n  // Returns the number of samples that have been successfuly written to the\n  // queue. `buf` is not written to during this call, so the samples that\n  // haven't been written to the queue are still available.\n  enqueue(buf) {\n    return this.ringbuf.push(buf);\n  }\n  // Query the free space in the ring buffer. This is the amount of samples that\n  // can be queued, with a guarantee of success.\n  available_write() {\n    return this.ringbuf.available_write();\n  }\n}\n\nclass AudioReader {\n  constructor(ringbuf) {\n    if (ringbuf.type() != \"Float32Array\") {\n      throw \"This class requires a ring buffer of Float32Array\";\n    }\n    this.ringbuf = ringbuf;\n  }\n  // Attempt to dequeue at most `buf.length` samples from the queue. This\n  // returns the number of samples dequeued. If greater than 0, the samples are\n  // at the beginning of `buf`\n  dequeue(buf) {\n    if (this.ringbuf.empty()) {\n      return 0;\n    }\n    return this.ringbuf.pop(buf);\n  }\n  // Query the occupied space in the queue. This is the amount of samples that\n  // can be read with a guarantee of success.\n  available_read() {\n    return this.ringbuf.available_read();\n  }\n}\n\n// Communicate parameter changes, lock free, no gc.\n//\n// between a UI thread (browser main thread or worker) and a real-time thread\n// (in an AudioWorkletProcessor). Write and Reader cannot change role after\n// setup, unless externally synchronized.\n//\n// GC can happen during the initial construction of this object when hopefully\n// no audio is being output. This depends on the implementation.\n//\n// Parameter changes are like in the VST framework: an index and a float value\n// (no restriction on the value).\n//\n// This class supports up to 256 parameters, but this is easy to extend if\n// needed.\n//\n// An element is a index, that is an unsigned byte, and a float32, which is 4\n// bytes.\n\nclass ParameterWriter {\n  // From a RingBuffer, build an object that can enqueue a parameter change in\n  // the queue.\n  constructor(ringbuf) {\n    if (ringbuf.type() != \"Uint8Array\") {\n      throw \"This class requires a ring buffer of Uint8Array\";\n    }\n    const SIZE_ELEMENT = 5;\n    this.ringbuf = ringbuf;\n    this.mem = new ArrayBuffer(SIZE_ELEMENT);\n    this.array = new Uint8Array(this.mem);\n    this.view = new DataView(this.mem);\n  }\n  // Enqueue a parameter change for parameter of index `index`, with a new value\n  // of `value`.\n  // Returns true if enqueuing suceeded, false otherwise.\n  enqueue_change(index, value) {\n    const SIZE_ELEMENT = 5;\n    this.view.setUint8(0, index);\n    this.view.setFloat32(1, value);\n    if (this.ringbuf.available_write() < SIZE_ELEMENT) {\n      return false;\n    }\n    return this.ringbuf.push(this.array) == SIZE_ELEMENT;\n  }\n}\n\nclass ParameterReader {\n  constructor(ringbuf) {\n    const SIZE_ELEMENT = 5;\n    this.ringbuf = ringbuf;\n    this.mem = new ArrayBuffer(SIZE_ELEMENT);\n    this.array = new Uint8Array(this.mem);\n    this.view = new DataView(this.mem);\n  }\n  dequeue_change(o) {\n    if (this.ringbuf.empty()) {\n      return false;\n    }\n    var rv = this.ringbuf.pop(this.array);\n    o.index = this.view.getUint8(0);\n    o.value = this.view.getFloat32(1);\n\n    return true;\n  }\n}\n\n// A Single Producer - Single Consumer thread-safe wait-free ring buffer.\n//\n// The producer and the consumer can be separate thread, but cannot change role,\n// except with external synchronization.\n\nclass RingBuffer {\n  static getStorageForCapacity(capacity, type) {\n    if (!type.BYTES_PER_ELEMENT) {\n      throw \"Pass in a ArrayBuffer subclass\";\n    }\n    var bytes = 8 + (capacity + 1) * type.BYTES_PER_ELEMENT;\n    return new SharedArrayBuffer(bytes);\n  }\n  // `sab` is a SharedArrayBuffer with a capacity calculated by calling\n  // `getStorageForCapacity` with the desired capacity.\n  constructor(sab, type) {\n    if (!ArrayBuffer.__proto__.isPrototypeOf(type) &&\n      type.BYTES_PER_ELEMENT !== undefined) {\n      throw \"Pass a concrete typed array class as second argument\";\n    }\n\n    // Maximum usable size is 1<<32 - type.BYTES_PER_ELEMENT bytes in the ring\n    // buffer for this version, easily changeable.\n    // -4 for the write ptr (uint32_t offsets)\n    // -4 for the read ptr (uint32_t offsets)\n    // capacity counts the empty slot to distinguish between full and empty.\n    this._type = type;\n    this.capacity = (sab.byteLength - 8) / type.BYTES_PER_ELEMENT;\n    this.buf = sab;\n    this.write_ptr = new Uint32Array(this.buf, 0, 1);\n    this.read_ptr = new Uint32Array(this.buf, 4, 1);\n    this.storage = new type(this.buf, 8, this.capacity);\n  }\n  // Returns the type of the underlying ArrayBuffer for this RingBuffer. This\n  // allows implementing crude type checking.\n  type() {\n    return this._type.name;\n  }\n  // Push bytes to the ring buffer. `bytes` is an typed array of the same type\n  // as passed in the ctor, to be written to the queue.\n  // Returns the number of elements written to the queue.\n  push(elements) {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    if ((wr + 1) % this._storage_capacity() == rd) {\n      // full\n      return 0;\n    }\n\n    let to_write = Math.min(this._available_write(rd, wr), elements.length);\n    let first_part = Math.min(this._storage_capacity() - wr, to_write);\n    let second_part = to_write - first_part;\n\n    this._copy(elements, 0, this.storage, wr, first_part);\n    this._copy(elements, first_part, this.storage, 0, second_part);\n\n    // publish the enqueued data to the other side\n    Atomics.store(\n      this.write_ptr,\n      0,\n      (wr + to_write) % this._storage_capacity()\n    );\n\n    return to_write;\n  }\n  // Read `elements.length` elements from the ring buffer. `elements` is a typed\n  // array of the same type as passed in the ctor.\n  // Returns the number of elements read from the queue, they are placed at the\n  // beginning of the array passed as parameter.\n  pop(elements) {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    if (wr == rd) {\n      return 0;\n    }\n\n    let to_read = Math.min(this._available_read(rd, wr), elements.length);\n\n    let first_part = Math.min(this._storage_capacity() - rd, elements.length);\n    let second_part = to_read - first_part;\n\n    this._copy(this.storage, rd, elements, 0, first_part);\n    this._copy(this.storage, 0, elements, first_part, second_part);\n\n    Atomics.store(this.read_ptr, 0, (rd + to_read) % this._storage_capacity());\n\n    return to_read;\n  }\n\n  // True if the ring buffer is empty false otherwise. This can be late on the\n  // reader side: it can return true even if something has just been pushed.\n  empty() {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    return wr == rd;\n  }\n\n  // True if the ring buffer is full, false otherwise. This can be late on the\n  // write side: it can return true when something has just been poped.\n  full() {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n\n    return (wr + 1) % this.capacity != rd;\n  }\n\n  // The usable capacity for the ring buffer: the number of elements that can be\n  // stored.\n  capacity() {\n    return this.capacity - 1;\n  }\n\n  // Number of elements available for reading. This can be late, and report less\n  // elements that is actually in the queue, when something has just been\n  // enqueued.\n  available_read() {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n    return this._available_read(rd, wr);\n  }\n\n  // Number of elements available for writing. This can be late, and report less\n  // elemtns that is actually available for writing, when something has just\n  // been dequeued.\n  available_write() {\n    var rd = Atomics.load(this.read_ptr, 0);\n    var wr = Atomics.load(this.write_ptr, 0);\n    return this._available_write(rd, wr);\n  }\n\n  // private methods //\n\n  // Number of elements available for reading, given a read and write pointer..\n  _available_read(rd, wr) {\n    if (wr > rd) {\n      return wr - rd;\n    } else {\n      return wr + this._storage_capacity() - rd;\n    }\n  }\n\n  // Number of elements available from writing, given a read and write pointer.\n  _available_write(rd, wr) {\n    let rv = rd - wr - 1;\n    if (wr >= rd) {\n      rv += this._storage_capacity();\n    }\n    return rv;\n  }\n\n  // The size of the storage for elements not accounting the space for the index.\n  _storage_capacity() {\n    return this.capacity;\n  }\n\n  // Copy `size` elements from `input`, starting at offset `offset_input`, to\n  // `output`, starting at offset `offset_output`.\n  _copy(input, offset_input, output, offset_output, size) {\n    for (var i = 0; i < size; i++) {\n      output[offset_output + i] = input[offset_input + i];\n    }\n  }\n}\n\nexports.AudioReader = AudioReader;\nexports.AudioWriter = AudioWriter;\nexports.ParameterReader = ParameterReader;\nexports.ParameterWriter = ParameterWriter;\nexports.RingBuffer = RingBuffer;\nexports.deinterleave = deinterleave;\nexports.interleave = interleave;\n\n\ntry {\n   AudioContext = window.AudioContext || window.webkitAudioContext;\n   audioCtx = new AudioContext();\n} catch (e) {\n   throw \"Could not instantiate AudioContext: \" + e.message;\n}\n// global var getUserMedia mic stream\nlet gumStream;\n// global audio node variables\nlet mic;\nlet gain;\nlet melspectrogramNode;\n\n// Plot Settings\nconst plot = {\n    canvas: document.createElement('canvas'),\n    movingWindowWidth: 350,\n    get wPixelRatio() {\n        return this.layoutWidth/this.canvas.width;\n    },\n    get hPixelRatio() {\n        return this.layoutHeight/this.canvas.height;\n    },\n    layoutWidth: 700,\n    layoutHeight: 288,\n    isFull: false,\n    offset: 50,\n    cursor: 0,\n    spectrumAccum: [],\n    init: function() {\n        this.canvas.width = this.movingWindowWidth;\n        this.canvas.height = melNumBands;\n        this.canvas.style.width = `${this.layoutWidth}px`;\n        this.canvas.style.height = `${this.layoutHeight}px`;\n        this.canvas.style.backgroundColor = 'transparent';\n        this.ctx = this.canvas.getContext('2d');\n    },\n    resetState: function () {\n        this.cursor = 0;\n        this.isFull = false;\n        this.canvas.width = this.movingWindowWidth;\n        // clear this.canvas to zero\n        let fullCanvasSlice = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n        let data = fullCanvasSlice.data;\n        data = data.fill(0);\n        this.ctx.putImageData(fullCanvasSlice, 0, 0);\n        // clear full spectro\n        this.spectrumAccum = [];\n    }\n};\n\n// Axes Settings\nconst axes = {\n    canvas: document.getElementById('axesDiv'),\n    xOffset: plot.offset-1,\n    yOffset: plot.offset+1.5,\n    tickWidth: 6,\n    fontSize: 12, \n    xLabel: \"Time (sec)\", \n    yLabel: \"Melbands\", \n    xticks: [], \n    xtickLabels: [],\n    get xtickSeparation() {\n        return this.xtimeStep*(audioCtx.sampleRate/bufferSize)*plot.wPixelRatio; // leave timeStep * frames/second * pixels each takes up between ticks\n    },\n    yticks: [], \n    ytickSeparation: plot.layoutHeight / 6, \n    xtimeStep: 1, // place xtick every <timeStep> seconds\n    init: function() {\n        this.canvas.width = 800;\n        this.canvas.height = 388;\n        this.ctx = this.canvas.getContext('2d');\n        this.ctx.strokeStyle = \"#8c8c8c\";\n        this.ctx.fillStyle = \"#8c8c8c\";\n        this.ctx.lineWidth = 1;\n\n        // calculate tick pixel coordinates\n        for (let i=0; i < 6; i++) {\n            this.yticks.push([this.xOffset, this.yOffset+(i*this.ytickSeparation)]);\n        }\n\n        this.drawAxes();\n        this.drawYTicks();\n        this.resetXAxis(1);\n    },\n    clearXTicks: function() {\n        this.ctx.clearRect(this.xOffset, this.yOffset+plot.layoutHeight+1, this.canvas.width-this.xOffset, this.tickWidth); \n    },\n    clearXTickLabels: function() {\n        this.ctx.clearRect(this.xOffset, this.yOffset+plot.layoutHeight+this.tickWidth+1, this.canvas.width-this.xOffset, this.fontSize);\n    },\n    calculateXTicks: function(step) {\n        this.xtimeStep = step;\n        this.xticks = [];\n        for (let j=this.xtickSeparation; j <= plot.layoutWidth; j += this.xtickSeparation) {\n            this.xticks.push([this.xOffset+j, this.yOffset+plot.layoutHeight]);\n        }\n    },\n    drawXTicks: function() {\n        // x ticks & labels\n        this.ctx.font = `${this.fontSize}px sans-serif`; \n        this.ctx.beginPath();\n        this.xticks.forEach((tick, idx) => {\n            this.ctx.moveTo(tick[0], tick[1]);\n            this.ctx.lineTo(tick[0], this.yOffset+plot.layoutHeight+this.tickWidth);\n        });\n        this.ctx.stroke();\n    },\n    calculatXTickLabels: function() {\n        this.xtickLabels = [];\n        this.xticks.forEach((t) => {\n            const labelValue = this.xtimeStep*(t[0]-this.xOffset)/this.xtickSeparation;\n            this.xtickLabels.push(Math.trunc(labelValue*10)/10);\n        })\n    },\n    drawXTickLabels: function() {\n        this.ctx.fillStyle = \"#8c8c8c\";\n        this.xticks.forEach((tick, idx) => {\n            this.ctx.fillText(this.xtickLabels[idx], tick[0]-(this.fontSize/3), this.canvas.height-(this.yOffset*0.6));\n        });\n    },\n    clearPlotArea: function() {\n        // clear axes plot area\n        // get black image of size plotLayout[Width/Height]\n        let emptyImageData = this.ctx.createImageData(plot.layoutWidth, plot.layoutHeight);\n        // put empty image data\n        this.ctx.putImageData(emptyImageData, plot.offset, plot.offset);\n    },\n    drawYTicks: function() {\n        // y ticks & labels\n        this.ctx.font = `${this.fontSize}px sans-serif`;\n        this.ctx.beginPath();\n        this.yticks.forEach((tick) => {\n            this.ctx.moveTo(tick[0], tick[1]);\n            this.ctx.lineTo(this.xOffset-this.tickWidth, tick[1]);\n            this.ctx.fillText(96 - (tick[1]-this.yOffset)/plot.hPixelRatio, this.xOffset*0.6, tick[1]+(this.fontSize/3));\n        });\n        this.ctx.stroke();\n    },\n    drawAxes: function() {\n        // main axes\n        this.ctx.moveTo(this.xOffset, this.yOffset);\n        this.ctx.lineTo(this.xOffset, this.yOffset+plot.layoutHeight);\n        this.ctx.lineTo(this.xOffset+plot.layoutWidth, this.yOffset+plot.layoutHeight);\n        this.ctx.stroke();\n        this.ctx.font = `${this.fontSize + 2}px sans-serif`;\n        let xtext = this.ctx.measureText(this.xLabel);\n        this.ctx.fillText(this.xLabel, this.xOffset+(plot.layoutWidth*0.5-(xtext.width*0.5)), this.canvas.height-10);\n        this.ctx.fillText(this.yLabel, 10, 30);\n    },\n    resetXAxis: function(step) {\n        this.clearXTicks();\n        this.clearXTickLabels();\n        this.calculateXTicks(step);\n        this.calculatXTickLabels();\n        this.drawXTicks();\n        this.drawXTickLabels();\n    }\n};\nlet animationLoopId;\n// Shared data with AudioWorkletGlobalScope\nlet audioReader;\n// Volume constants\nconst x_dim = 4;\nconst y_dim = 4;\nconst z_dim = 4;\nconst x_scale = 1;\nconst y_scale = 1;\nconst z_scale = 1;\n \n// Magenta Music  spectrogram constants\nconst SAMPLE_RATE = 16000;\nconst MEL_SPEC_BINS = 229;\nconst SPEC_HOP_LENGTH = 512;\n \n// Live Audio spectrogram constants\nconst FFT_SIZE = 2048;\nconst NUM_FRAMES = 100;\nconst MIN_DB = -80;\nconst MAX_DB = -10;\n \n// Curve constants\nconst NUM_CURVE_POINTS = 5;\n \n \n// Setup audio\n \nlet navigatorCopy = navigator;\nif (navigatorCopy.mediaDevices === undefined) {\n navigatorCopy.mediaDevices = {};\n}\n// Some browsers partially implement mediaDevices. We can't assign an object\n// with getUserMedia as it would overwrite existing properties.\n// Add the getUserMedia property if it's missing.\n \n// Set up UI Elements\nconst fileInput = document.getElementById('loadFileInput');\nconst recordButton = document.getElementById('recordButton');\n \n// Set up event listeners\n \naddEventListener('change', () => loadFile(fileInput, 'loadFileBtn'));\n// Load audio file, generate mel spectrogram\n// and return the spectrogram's data texture\nfunction loadFile(inputElement, prefix) {\n //document.getElementById(`${prefix}_fileBtn`).setAttribute('disabled', '');\n const audioBuffer = loadAudioFromFile(inputElement.files[0]);\n return audioBuffer\n .then(\n   (buffer) => {return preprocessAudio(buffer)})\n .then(\n   (melSpec) => {\n     return createMMSpectrumDataTexture(melSpec, melSpec.length, MEL_SPEC_BINS)\n     }\n )\n .then(\n   (dataTexture) => {return setMeshTexture(dataTexture)}\n );\n}\n \n// Compute mel spectrogram\nasync function preprocessAudio(audioBuffer) {\n const resampledMonoAudio = await resampleAndMakeMono(audioBuffer);\n return powerToDb(melSpectrogram(resampledMonoAudio, {\n   sampleRate: SAMPLE_RATE,\n   hopLength: SPEC_HOP_LENGTH,\n   nMels: MEL_SPEC_BINS,\n   // temporal resolution\n   nFft: 2048,\n   fMin: 30,\n }));\n}\n\n// Shaders\nconst raycastVertexShader = /* glsl */`\nuniform vec3 volume_scale;\nout vec3 vray_dir;\nflat out vec3 transformed_eye;\nvoid main(void) {\n // TODO: For non-uniform size volumes we need to transform them differently as well\n // to center them properly\n vec3 volume_translation = vec3(0.5) - volume_scale * 0.5;\n gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1);\n transformed_eye = (cameraPosition - volume_translation) / volume_scale;\n vray_dir = position - transformed_eye;\n}`;\nconst raycastFragmentShader = /* glsl */`\nprecision highp int;\nprecision highp float;\nuniform highp sampler3D volume;\nuniform highp sampler2D spectrum;\nuniform highp sampler2D curve_data;\nuniform ivec3 volume_dims;\nuniform vec3 volume_scale;\nuniform float dt_scale;\nuniform vec3 aabb_min;\nuniform vec3 aabb_max;\nuniform float time;\nin vec3 vray_dir;\nflat in vec3 transformed_eye;\n \nvec2 intersect_box(vec3 aabbMin, vec3 aabbMax, vec3 orig, vec3 dir) {\n \n vec3 inv_dir = 1.0 / dir;\n vec3 tmin_tmp = (aabbMin - orig) * inv_dir;\n vec3 tmax_tmp = (aabbMax - orig) * inv_dir;\n vec3 tmin = min(tmin_tmp, tmax_tmp);\n vec3 tmax = max(tmin_tmp, tmax_tmp);\n float t0 = max(tmin.x, max(tmin.y, tmin.z));\n float t1 = min(tmax.x, min(tmax.y, tmax.z));\n return vec2(t0, t1);\n}\n// Pseudo-random number gen from\n// http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\n// with some tweaks for the range of values\nfloat wang_hash(int seed) {\n seed = (seed ^ 61) ^ (seed >> 16);\n seed *= 9;\n seed = seed ^ (seed >> 4);\n seed *= 0x27d4eb2d;\n seed = seed ^ (seed >> 15);\n return float(seed % 2147483647) / float(2147483647);\n}\nfloat linear_to_srgb(float x) {\n if (x <= 0.0031308f) {\n   return 12.92f * x;\n }\n return 1.055f * pow(x, 1.f / 2.4f) - 0.055f;\n}\nvec4 color_transfer(float intensity)\n{\n vec3 high = vec3(0.0, 0.0, 0.0);\n vec3 low = vec3(1.0, 1.0, 1.0);\n float alpha = (exp(intensity) - 1.0) / (exp(1.0) - 1.0);\n return vec4(intensity * high + (1.0 - intensity) * low, alpha);\n}\n \nfloat sdSphere( vec3 p, vec3 offset, float scale )\n{\n float dist = length(p - offset) - scale;\n return 1.0 - clamp(dist, 0.0, 1.0);\n}\nfloat distCurve(vec3 p){\n float min_dist = 10.0;\n float du = 0.2;\n float u = 0.0;\n while(u < 1.0 ){\n   vec2 v_pos = vec2(u, 0.0);\n   // point normals are stored in the 3rd row of the texture\n   // whose UV.v coordinate is 0.75\n   vec2 v_norm = vec2(u, 0.75);\n   vec3 dir_vec = p - texture(curve_data, v_pos).rgb ;\n \n   min_dist = min(min_dist, length(dir_vec));\n   u += du;\n }\n \n return min_dist;\n}\n \nvoid main(void) {\n vec3 ray_dir = normalize(vray_dir);\n vec4 color = vec4(0.0);\n vec2 t_hit = intersect_box(aabb_min, aabb_max, transformed_eye, ray_dir);\n if (t_hit.x > t_hit.y) {\n   discard;\n }\n t_hit.x = max(t_hit.x, 0.0);\n vec3 dt_vec = 1.0 / (vec3(volume_dims) * abs(ray_dir));\n float dt = dt_scale * min(dt_vec.x, min(dt_vec.y, dt_vec.z));\n vec3 p = transformed_eye + (t_hit.x + dt) * ray_dir;\n int step = 0;\n int maxStep = 100 ;\n for (float t = t_hit.x; t < t_hit.y; t += dt) {\n   if (step > maxStep){\n     break;\n   }\n   // use distance function\n   // infinite tube\n   float dist = length(p.xy) - 0.01;\n   // sphere\n   // float dist = clamp(length(p), 0.0, 1.0);\n   // curve\n   // float dist = distCurve(p) * 1.0;\n   // sample spectrogram\n   vec4 spec_val = texture(spectrum, vec2(0.5,  0.03 / dist));\n   vec4 val_color = vec4(pow(spec_val.r,10.0) ,pow(spec_val.r, 2.0),0.0 * pow(spec_val.r,0.0),spec_val.r);\n   //vec4 val_color = vec4(pow(dist,8.0),dist,dist,dist);\n   // Opacity correction\n   val_color.w = 1.0 - pow(1.0 - val_color.w, dt_scale);\n \n   // Alpha-blending\n   color.xyz += (1.0 - color.w) * val_color.w * val_color.xyz;\n   color.w += (1.0 - color.w) * val_color.w;\n   // if (color.w > 0.99) {\n   //   break;\n   // }\n   if (val_color.w < 0.0) {\n     discard;\n   }\n   p += ray_dir * dt;\n   step++;\n }\n color.x = linear_to_srgb(color.x);\n color.y = linear_to_srgb(color.y);\n color.z = linear_to_srgb(color.z);\n gl_FragColor = color;\n //gl_FragColor = vec4(texture(spectrum,vec2(0.0,0.0)).rgb * 255.0, 1.0);\n \n}\n`;\n \n// Main body\ninit();\nanimate();\n \n \nfunction init() {\n scene = new THREE.Scene();\n \n // Renderer\n renderer = new THREE.WebGLRenderer({antialias: true});\n renderer.setPixelRatio( window.devicePixelRatio );\n renderer.setSize( window.innerWidth, window.innerHeight );\n //document.body.appendChild( renderer.domElement );\n \n // Camera\n // Perspective\n const aspect = window.innerWidth / window.innerHeight;\n camera = new THREE.PerspectiveCamera( 45, aspect, 0.01, 1000 );\n // // Orthographic\n // const width = 5;\n // const h = 2 * width; // frustum height\n // const aspect = window.innerWidth / window.innerHeight;\n // camera = new THREE.OrthographicCamera( - h * aspect / 2, h * aspect / 2, h / 2, - h / 2, 0.01, 1000 );\n camera.position.set( 0, 0, 10 );\n  scene.add(camera);\n \n // Controls\n controls = new OrbitControls( camera, renderer.domElement );\n controls.addEventListener( 'change', render );\n controls.minZoom = 0.1;\n controls.maxZoom = 10;\n controls.enablePan = false;\n controls.update();\n \n // Debug spectrogram texture\n let planeGeo1 = new THREE.PlaneGeometry(2, 2);\n let planeMat1 = new THREE.MeshBasicMaterial({ map: createDataTexture(x_dim, y_dim), side: THREE.DoubleSide});\n debugPlaneMesh = new THREE.Mesh(planeGeo1, planeMat1);\n debugPlaneMesh .position.set( -2, 0, -1 );\n scene.add(debugPlaneMesh);\n \n // Volume\n const volumeGeometry = new THREE.BoxGeometry( x_scale, y_scale, z_scale);\n clock = new THREE.Clock();\n \n const curve = initCurveData(NUM_CURVE_POINTS);\n const points = curve.getPoints( 5 );\n const geometry = new THREE.BufferGeometry().setFromPoints( points );\n const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );\n \n // Create curveMesh to add to the scene\n curveMesh = new THREE.Line( geometry, material );\n curveMesh.matrixAutoUpdate = false;\n scene.add(curveMesh);\n \n const volumeUniforms =  {\n   'volume_scale': { value: new THREE.Vector3( x_scale, y_scale, z_scale ) },\n   'volume': { value: create3dDataTexture(x_dim, y_dim, z_dim) },\n   'volume_dims': { value: new THREE.Vector3( x_dim, y_dim, z_dim) },\n   'aabb_min': { value: new THREE.Vector3()},\n   'aabb_max': { value: new THREE.Vector3()},\n   'dt_scale': { value: 0.1},\n   'spectrum': { value: createDataTexture(NUM_FRAMES, FFT_SIZE / 2) },\n   'curve_data': { value: createCurveDataTexture(curve_data) },\n   'time': {value: clock.getElapsedTime()}\n };\n \n const volumeMaterial = new THREE.ShaderMaterial({\n   uniforms: volumeUniforms,\n   vertexShader: raycastVertexShader,\n   fragmentShader: raycastFragmentShader,\n   side: THREE.DoubleSide,\n   transparent: true\n });\n \n volumeMesh = new THREE.Mesh( volumeGeometry, volumeMaterial);\n volumeMesh.matrixAutoUpdate = true;\n volumeMesh.geometry.computeBoundingBox();\n \n (volumeMesh.material).uniforms['aabb_min']['value'] = volumeMesh.geometry.boundingBox.min;\n (volumeMesh.material).uniforms['aabb_max']['value'] = volumeMesh.geometry.boundingBox.max;\n scene.add(volumeMesh);\n \n pointer = new THREE.Vector2();\n \n window.addEventListener('pointerMove', onPointerMove);\n \n const planeGeo = new THREE.PlaneGeometry(25, 25);\n const planeMat = new THREE.MeshBasicMaterial({visible: false});\n planeMesh = new THREE.Mesh(planeGeo, planeMat);\n planeMesh.rotation.x = -0.5 * Math.PI;\n scene.add(planeMesh);\n planeMesh.name = 'plane';\n \n raycaster = new THREE.Raycaster();\n \n // Add helpers\n addHelpers(scene);\n render();\n document.addEventListener( 'pointermove', onPointerMove );\n window.addEventListener( 'resize', onWindowResize ); \n recordButton.addEventListener('click', onRecordClickHandler);\n}\n \nfunction onWindowResize() {\n \n // renderer.setSize( window.innerWidth, window.innerHeight );\n \n // const aspect = window.innerWidth / window.innerHeight;\n \n // const frustumHeight = camera.top - camera.bottom;\n \n // camera.left = - frustumHeight * aspect / 2;\n // camera.right = frustumHeight * aspect / 2;\n \n // camera.updateProjectionMatrix();\n camera.aspect = window.innerWidth / window.innerHeight;\n camera.updateProjectionMatrix();\n \n renderer.setSize( window.innerWidth, window.innerHeight );\n \n render();\n \n}\n \nfunction onPointerMove(event) {\n \n pointer.x = (event.clientX / window.innerWidth) * 2 - 1;\n pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;\n \n}\n \nfunction addHelpers (scene) {\n const gridHelper = new THREE.GridHelper( 10, 10);\n scene.add( gridHelper );\n stats = Stats();\n document.body.appendChild(stats.dom)\n const axesHelper = new THREE.AxesHelper( 3 );\n scene.add( axesHelper );\n}\n \nfunction updateUniforms(){\n (volumeMesh.material).uniforms['time']['value'] = clock.getElapsedTime();\n (volumeMesh.material).uniforms['curve_data']['value'] =  updateCurveData(curveMesh, NUM_CURVE_POINTS);\n}\nfunction animate(){\n requestAnimationFrame(animate);\n updateUniforms();\n stats.update();\n //displayLiveSpectrum();\n render();\n}\n \n// Creates 3D texture with RGB gradient along the XYZ axes\nfunction create3dDataTexture(width, height, depth) {\n const d = new Uint8Array( width * height * depth * 4 );\n let stride = 0;\n \n for ( let z = 0; z < depth; z ++ ) {\n   for ( let y = 0; y < height; y ++ ) {\n     for ( let x = 0; x < width; x ++ ) {\n       d[stride + 0] = (x / width) * 255;\n       d[stride + 1] = (y / height) * 255;\n       d[stride + 2] = (z / depth) * 255;\n       // debug: looking at texture from side should give accumulated alpha of 1\n       d[stride + 3] = 255;\n       stride += 4;\n     }\n   }\n }\n const texture = new THREE.Data3DTexture( d, width, height, depth );\n texture.format = THREE.RGBAFormat;\n //texture.type = THREE.FloatType;\n // texture.minFilter = THREE.NearestFilter;\n // texture.magFilter = THREE.NearestFilter;\n texture.unpackAlignment = 1;\n texture.needsUpdate = true;\n \n return texture;\n}\nfunction createDataTexture(width, height) {\n \n const d = new Float32Array( width * height * 4 );\n \n let stride = 0;\n for ( let y = 0; y < height; y ++ ) {\n   for ( let x = 0; x < width; x ++ ) {\n     d[stride + 0] = 1;\n     d[stride + 1] = 0;\n     d[stride + 2] = 0;\n     d[stride + 3] = 1;\n     stride += 4;\n   }\n }\n const texture = new THREE.DataTexture( d, width, height );\n texture.format = THREE.RGBAFormat;\n texture.type = THREE.FloatType;\n texture.minFilter = THREE.NearestFilter;\n texture.magFilter = THREE.NearestFilter;\n texture.unpackAlignment = 1;\n texture.needsUpdate = true;\n \n return texture;\n}\nfunction createMMSpectrumDataTexture(data, width, height) {\n const d = new Float32Array( width * height * 4 );\n let stride = 0;\n for ( let y = 0; y < height; y ++ ) {\n   for ( let x = 0; x < width; x ++ ) {\n     d[stride + 0] = data[x][y];\n     d[stride + 1] = 0;\n     d[stride + 2] = 0;\n     d[stride + 3] = 0;\n     stride += 4;\n   }\n }\n var max = -Infinity;\n var min = Infinity;\n for(var i = 0; i < d.length; i++ ) if (d[i] > max) max = d[i];\n for(var i = 0; i < d.length; i++ ) if (d[i] < min) min = d[i];\n \n // normalize array\n stride = 0;\n while(stride < width * height * 4 ){\n   d[stride] = (d[stride] - min) / (max - min);\n   stride +=4;\n }\n const texture = new THREE.DataTexture( d, width, height );\n texture.format = THREE.RGBAFormat;\n texture.type = THREE.FloatType;\n texture.minFilter = THREE.NearestFilter;\n texture.magFilter = THREE.NearestFilter;\n texture.unpackAlignment = 1;\n texture.needsUpdate = true;\n \n return texture;\n}\nfunction createSpectrumDataTexture(width, height) {\n let data = [];\n for (let x = 0; x < width; x++){\n   data.push(new Float32Array(height));\n }\n return data;\n}\n \nfunction updateSpectrumData(texture, new_data) {\n const width = NUM_FRAMES;\n const height = FFT_SIZE / 2;\n const data = texture.image.data;\n let stride = 0;\n for (let y = 0; y < height; y++) {\n   for (let x = 0; x < width; x++) {\n     if (x < width - 10) {\n       // see https://webaudio.github.io/web-audio-api/#dom-analysernode-getbytefrequencydata\n       data[stride] = new_data[y] ;\n     } else {\n       data[stride] = data[stride + 4] ;\n     }\n     //data[stride] = Math.abs(Math.sin(clock.getElapsedTime()));\n     data[stride + 1] = 0;\n     data[stride + 2] = 0;\n     data[stride + 3] = 1;\n     stride += 4;\n   }\n }\n // const d_max = Math.max.apply(null, data);\n // const d_min = Math.min.apply(null, data);\n // // normalize array\n // stride = 0;\n // while(stride < width * height * 4 ){\n //   data[stride] = (data[stride] - d_min) / (d_max - d_min);\n //   stride +=4;\n // }\n // console.log(d_max);\n}\nfunction createCurveDataTexture(data){\n const d = new Float32Array( data.numPoints *  4 * 4 );\n let stride = 0;\n const pt_data = [data.positions, data.tangents, data.normals, data.binormals];\n for ( let j = 0; j < 4; j ++ ) {\n   for ( let k = 0; k < data.numPoints; k ++ ) {\n     d[stride + 0] = pt_data[j][k].x;\n     d[stride + 1] = pt_data[j][k].y;\n     d[stride + 2] = pt_data[j][k].z;\n     d[stride + 3] = 1.0;\n     stride += 4;\n   }\n }\n const texture = new THREE.DataTexture( d, data.numPoints, 1 );\n texture.type = THREE.FloatType;\n texture.format = THREE.RGBAFormat;\n texture.minFilter = THREE.NearestFilter;\n texture.magFilter = THREE.NearestFilter;\n texture.unpackAlignment = 1;\n texture.needsUpdate = true;\n return texture\n}\n \nfunction initCurveData(num_points){\n \n const curve = new THREE.CatmullRomCurve3( [\n   new THREE.Vector3( 0, 0.0, -0.5 ),\n   new THREE.Vector3(0, 0.0,  -0.25 ),\n   new THREE.Vector3( 0, 0.0 , 0),\n   new THREE.Vector3( 0, 0.0, 0.25 ),\n   new THREE.Vector3( 0, 0.0, 0.5 )\n ] );\n const cPoints = curve.getSpacedPoints(num_points);\n const  cObjects = curve.computeFrenetFrames(num_points, true);\n \n curve_data =  {\n   positions : cPoints,\n   tangents :cObjects.tangents,\n   normals : cObjects.normals,\n   binormals : cObjects.binormals,\n   numPoints : num_points\n }\n return curve;\n}\n \nfunction updateCurveData(curve_mesh, num_points){\n \n const geo_array = curve_mesh.geometry.attributes.position.array;\n \n // rebuild the curve\n const positions = Array(num_points);\n let i3 = 0;\n for (let i = 0; i < num_points ; i ++ ) {\n   if(i == num_points - 1){\n     positions[i] = new THREE.Vector3(\n       geo_array[i3 + 0],\n       geo_array[i3 + 1] + Math.abs(Math.sin(clock.getElapsedTime())),\n       geo_array[i3 + 2]);\n   }\n   else{\n     positions[i] = new THREE.Vector3(\n       geo_array[i3 + 0],\n       geo_array[i3 + 1],\n       geo_array[i3 + 2]);  \n   }\n   i3 += 3;\n }\n \n const curve = new THREE.CatmullRomCurve3(positions);\n const cPoints = curve.getSpacedPoints(num_points);\n const  cObjects = curve.computeFrenetFrames(num_points, true);\n \n // update curve_data interface\n curve_data =  {\n   positions : cPoints,\n   tangents :cObjects.tangents,\n   normals : cObjects.normals,\n   binormals : cObjects.binormals,\n   numPoints : num_points\n }\n \n return createCurveDataTexture(curve_data);\n}\nfunction setMeshTexture(texture){\n (debugPlaneMesh.material).map = texture;\n (debugPlaneMesh.material).dispose();\n (volumeMesh.material).uniforms['spectrum']['value'] = texture;\n (volumeMesh.material).dispose();\n}\nfunction render() {\n renderer.render(scene, camera);\n}\n// function onAudioMute(muteBtn: HTMLElement, gainNode: GainNode) {\n//   if (muteBtn.id == \"\") {\n//     gainNode.gain.value = 0;\n//     muteBtn.id = \"activated\";\n//     muteBtn.innerHTML = \"Unmute\";\n//   } else {\n//     gainNode.gain.value = 1;\n//     muteBtn.id = \"\";\n//     muteBtn.innerHTML = \"Mute\";\n//   }\n// }\n \nfunction displayLiveSpectrum() {\n analyser.fftSize = FFT_SIZE;\n let bufferLength = analyser.frequencyBinCount;\n let newFFTData = new Uint8Array(bufferLength);\n analyser.getByteFrequencyData(newFFTData);\n const texture = (volumeMesh.material).uniforms['spectrum']['value'];\n updateSpectrumData(texture, Float32Array.from(newFFTData));\n texture.needsUpdate = true;\n if (clock.getElapsedTime() < 0.1){\n   console.log((volumeMesh.material).uniforms['spectrum']['value']);\n   console.log((volumeMesh.material).uniforms['spectrum']['value'].format);\n }\n}\n \n// From a series of URL to js files, get an object URL that can be loaded in an\n// AudioWorklet. This is useful to be able to use multiple files (utils, data\n// structure, main DSP, etc.) without either using static imports, eval, manual\n// concatenation with or without a build step, etc.\nfunction URLFromFiles(files) {\n const promises = files\n     .map((file) => fetch(file)\n         .then((response) => response.text()));\n return Promise\n     .all(promises)\n     .then((texts) => {\n         texts.unshift(\"var exports = {};\"); // hack to make injected umd modules work\n         const text = texts.join('');\n         const blob = new Blob([text], {type: \"text/javascript\"});\n        \n         return URL.createObjectURL(blob);\n     });\n}\n \n// Utils:\nfunction arraySum(total, num) {\n   return total + num;\n}\n \n \nfunction onRecordClickHandler() {\n   let recording = recordButton.classList.contains(\"recording\");\n     if (!recording) {\n       recordButton.setAttribute(\"disabled\", true);\n       // start microphone stream using getUserMedia and runs the feature extraction\n       startMicRecordStream();\n     } else {\n       stopMicRecordStream();\n     }\n}\n \n// record native microphone input and do further audio processing on each audio buffer using the given callback functions\nfunction startMicRecordStream() {\n   if (navigator.mediaDevices.getUserMedia) {\n       console.log(\"Initializing audio...\");\n       navigator.mediaDevices.getUserMedia({ audio: true, video: false })\n       .then(startAudioProcessing)\n       .catch(function(message) {\n               throw \"Could not access microphone - \" + message;\n       });\n   } else {\n       throw \"Could not access microphone - getUserMedia not available\";\n   }\n}\n \nfunction startAudioProcessing(stream) {\n   gumStream = stream;\n   if (gumStream.active) {\n       // In most platforms where the sample rate is 44.1 kHz or 48 kHz,\n       // and the default bufferSize will be 4096, giving 10-12 updates/sec.\n       if (audioCtx.state == \"closed\") {\n           audioCtx = new AudioContext();\n       }\n       else if (audioCtx.state == \"suspended\") {\n           audioCtx.resume();\n       }\n \n       mic = audioCtx.createMediaStreamSource(gumStream);\n       gain = audioCtx.createGain();\n       gain.gain.setValueAtTime(0, audioCtx.currentTime);\n \n\n       let codeForProcessorModule = [\"https://cdn.jsdelivr.net/npm/essentia.js@0.1.3/dist/essentia-wasm.umd.js\",\n       \"https://cdn.jsdelivr.net/npm/essentia.js@0.1.3/dist/essentia.js-extractor.umd.js\", \n       \"https://raw.githack.com/MTG/essentia.js/master/examples/demos/melspectrogram-rt/melspectrogram-processor.js\",\n       \"https://unpkg.com/ringbuf.js@0.1.0/dist/index.js\"];\n \n       // inject Essentia.js code into AudioWorkletGlobalScope context, then setup audio graph and start animation\n       URLFromFiles(codeForProcessorModule)\n       .then((concatenatedCode) => {\n           audioCtx.audioWorklet.addModule(concatenatedCode)\n           .then(setupAudioGraph)\n           .catch( function moduleLoadRejected(msg) {\n               console.log(`There was a problem loading the AudioWorklet module code: \\n ${msg}`);\n           });\n       })\n       .catch((msg) => {\n           console.log(`There was a problem retrieving the AudioWorklet module code: \\n ${msg}`);\n       })\n       // set button to stop\n       recordButton.classList.add(\"recording\");\n       recordButton.innerHTML = \"STOP\";\n       recordButton.setAttribute(\"disabled\", false);\n   } else {\n       throw \"Mic stream not active\";\n   }\n}\n \nfunction setupAudioGraph() {\n   // 50ms of buffer, increase in case of glitches\n   let sab = exports.RingBuffer.getStorageForCapacity(melNumBands*18, Float32Array);\n   let rb = new exports.RingBuffer(sab, Float32Array);\n   audioReader = new exports.AudioReader(rb);\n \n   melspectrogramNode = new AudioWorkletNode(audioCtx, 'melspectrogram-processor', {\n       processorOptions: {\n           bufferSize: bufferSize,\n           hopSize: hopSize,\n           melNumBands: melNumBands,\n           sampleRate: audioCtx.sampleRate,\n       }\n   });\n \n   try {\n       melspectrogramNode.port.postMessage({\n           sab: sab,\n       });\n   } catch(_){\n       alert(\"No SharedArrayBuffer transfer support, try another browser.\");\n       recordButton.setAttribute(\"disabled\", true);\n       return;\n   }\n \n   // It seems necessary to connect the stream to a sink for the pipeline to work, contrary to documentataions.\n   // As a workaround, here we create a gain node with zero gain, and connect temp to the system audio output.\n   mic.connect(melspectrogramNode);\n   melspectrogramNode.connect(gain);\n   gain.connect(audioCtx.destination);\n \n   requestAnimationFrame(animateSpectrogram); // start plot animation\n}\n \nlet animationStart;\nlet elapsed;\n// draw melspectrogram frames\nfunction animateSpectrogram(timestamp) {\n   if (animationStart === undefined)\n       animationStart = timestamp;\n   elapsed = timestamp - animationStart;\n   animationLoopId = requestAnimationFrame(animateSpectrogram);\n   /* SAB method */\n   let melspectrumBuffer = new Float32Array(melNumBands);\n   if (audioReader.available_read() >= melNumBands) {\n       let toread = audioReader.dequeue(melspectrumBuffer);\n       if (toread !== 0) {\n           // scale spectrum values to 0 - 255\n           let scaledMelspectrum = melspectrumBuffer.map(x => Math.round(x*35.5))\n           // save into full spectrogram for drawing on stop\n \n       }\n   }\n}\n \n \n\n \n \n \n \n \n\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","__webpack_require__.amdD = function () {\n\tthrow new Error('define cannot be used indirect');\n};","__webpack_require__.amdO = {};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t947: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunk\"] = self[\"webpackChunk\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [365,53,124], () => (__webpack_require__(761)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","camera","scene","renderer","controls","stats","raycaster","planeMesh","debugPlaneMesh","volumeMesh","pointer","clock","curveMesh","curve_data","AudioContext","audioCtx","WebGL","document","body","appendChild","gumStream","mic","gain","melspectrogramNode","exports","Object","defineProperty","value","AudioReader","constructor","ringbuf","type","this","dequeue","buf","empty","pop","available_read","AudioWriter","enqueue","push","available_write","ParameterReader","mem","ArrayBuffer","array","Uint8Array","view","DataView","dequeue_change","o","index","getUint8","getFloat32","ParameterWriter","enqueue_change","setUint8","setFloat32","RingBuffer","static","capacity","BYTES_PER_ELEMENT","bytes","SharedArrayBuffer","sab","__proto__","isPrototypeOf","undefined","_type","byteLength","write_ptr","Uint32Array","read_ptr","storage","name","elements","rd","Atomics","load","wr","_storage_capacity","to_write","Math","min","_available_write","length","first_part","second_part","_copy","store","to_read","_available_read","full","rv","input","offset_input","output","offset_output","size","i","deinterleave","channel_count","channelCount","out_channel","interleaved_idx","j","interleave","out_idx","window","webkitAudioContext","e","message","plot","canvas","createElement","movingWindowWidth","wPixelRatio","layoutWidth","width","hPixelRatio","layoutHeight","height","isFull","offset","cursor","spectrumAccum","init","style","backgroundColor","ctx","getContext","resetState","fullCanvasSlice","getImageData","data","fill","putImageData","animationLoopId","audioReader","getElementById","navigatorCopy","navigator","mediaDevices","fileInput","recordButton","onWindowResize","aspect","innerWidth","innerHeight","updateProjectionMatrix","setSize","render","onPointerMove","event","x","clientX","y","clientY","create3dDataTexture","depth","d","stride","z","texture","THREE","format","unpackAlignment","needsUpdate","createDataTexture","Float32Array","minFilter","magFilter","createCurveDataTexture","numPoints","pt_data","positions","tangents","normals","binormals","k","onRecordClickHandler","classList","contains","stopMicRecordStream","setAttribute","getUserMedia","console","log","audio","video","then","startAudioProcessing","catch","startMicRecordStream","stream","active","state","resume","createMediaStreamSource","createGain","setValueAtTime","currentTime","files","promises","map","file","fetch","response","text","Promise","all","texts","unshift","join","blob","Blob","URL","createObjectURL","URLFromFiles","concatenatedCode","audioWorklet","addModule","setupAudioGraph","msg","add","innerHTML","getStorageForCapacity","melNumBands","rb","AudioWorkletNode","processorOptions","bufferSize","hopSize","sampleRate","port","postMessage","_","alert","connect","destination","requestAnimationFrame","animateSpectrogram","animationStart","elapsed","timestamp","melspectrumBuffer","round","addEventListener","loadFile","inputElement","loadAudioFromFile","buffer","async","audioBuffer","resampledMonoAudio","resampleAndMakeMono","powerToDb","melSpectrogram","hopLength","nMels","nFft","fMin","preprocessAudio","melSpec","max","Infinity","createMMSpectrumDataTexture","dataTexture","material","dispose","uniforms","antialias","setPixelRatio","devicePixelRatio","position","set","OrbitControls","domElement","minZoom","maxZoom","enablePan","update","planeGeo1","planeMat1","side","volumeGeometry","points","num_points","curve","cPoints","getSpacedPoints","cObjects","computeFrenetFrames","initCurveData","getPoints","geometry","setFromPoints","color","matrixAutoUpdate","volumeUniforms","FFT_SIZE","getElapsedTime","volumeMaterial","vertexShader","fragmentShader","transparent","computeBoundingBox","boundingBox","planeGeo","planeMat","visible","rotation","PI","gridHelper","Stats","dom","axesHelper","addHelpers","animate","curve_mesh","geo_array","attributes","Array","i3","abs","sin","updateCurveData","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","id","loaded","__webpack_modules__","call","m","amdD","Error","amdO","O","result","chunkIds","fn","priority","notFulfilled","fulfilled","keys","every","key","splice","r","definition","enumerable","get","g","globalThis","Function","obj","prop","prototype","hasOwnProperty","Symbol","toStringTag","nmd","paths","children","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","some","chunkLoadingGlobal","self","forEach","bind","__webpack_exports__"],"sourceRoot":""}