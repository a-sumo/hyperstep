{"version":3,"file":"bundle.a4cadd2590bac49be79e.js","mappings":"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","sources":["webpack:///./node_modules/three-mesh-bvh/src/core/Constants.js","webpack:///./node_modules/three-mesh-bvh/src/core/MeshBVHNode.js","webpack:///./node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js","webpack:///./node_modules/three-mesh-bvh/src/core/buildFunctions.js","webpack:///./node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js","webpack:///./node_modules/three-mesh-bvh/src/math/MathUtilities.js","webpack:///./node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js","webpack:///./node_modules/three-mesh-bvh/src/math/OrientedBox.js","webpack:///./node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js","webpack:///./node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js","webpack:///./node_modules/three-mesh-bvh/src/utils/PrimitivePool.js","webpack:///./node_modules/three-mesh-bvh/src/core/castFunctions.js","webpack:///./node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js","webpack:///./node_modules/three-mesh-bvh/src/core/MeshBVH.js","webpack:///./node_modules/three-mesh-bvh/src/core/nodeBufferFunctions.js"],"sourcesContent":["// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\n","export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t}\n\n}\n","export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copys bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n","import { BufferAttribute } from 'three';\nimport { MeshBVHNode } from './MeshBVHNode.js';\nimport { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../utils/ArrayBoxUtilities.js';\nimport {\n\tCENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST,\n\tBYTES_PER_NODE, FLOAT32_EPSILON, IS_LEAFNODE_FLAG,\n} from './Constants.js';\n\nfunction ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tlet index;\n\t\tif ( vertexCount > 65535 ) {\n\n\t\t\tindex = new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t\t} else {\n\n\t\t\tindex = new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t\t}\n\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nfunction getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn [ { offset: 0, count: geo.index.count / 3 } ];\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\tfor ( const group of geo.groups ) {\n\n\t\trangeBoundaries.add( group.start );\n\t\trangeBoundaries.add( group.start + group.count );\n\n\t}\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ], end = sortedBoundaries[ i + 1 ];\n\t\tranges.push( { offset: ( start / 3 ), count: ( end - start ) / 3 } );\n\n\t}\n\n\treturn ranges;\n\n}\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nfunction getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tconst includeCentroid = centroidTarget !== null;\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tif ( includeCentroid ) {\n\n\t\tcentroidTarget[ 0 ] = cminx;\n\t\tcentroidTarget[ 1 ] = cminy;\n\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t}\n\n}\n\n// A stand alone function for retrieving the centroid bounds.\nfunction getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t\tlet t1 = triangleBounds[ left * 6 + i * 2 + 0 ];\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 0 ] = triangleBounds[ right * 6 + i * 2 + 0 ];\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 0 ] = t1;\n\n\t\t\t\tlet t2 = triangleBounds[ left * 6 + i * 2 + 1 ];\n\t\t\t\ttriangleBounds[ left * 6 + i * 2 + 1 ] = triangleBounds[ right * 6 + i * 2 + 1 ];\n\t\t\t\ttriangleBounds[ right * 6 + i * 2 + 1 ] = t2;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nfunction getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// dont do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nfunction computeTriangleBounds( geo, fullBounds ) {\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index.array;\n\tconst triCount = index.length / 3;\n\tconst triangleBounds = new Float32Array( triCount * 6 );\n\tconst normalized = posAttr.normalized;\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai, bi, ci;\n\n\t\tif ( normalized ) {\n\n\t\t\tai = index[ tri3 + 0 ];\n\t\t\tbi = index[ tri3 + 1 ];\n\t\t\tci = index[ tri3 + 2 ];\n\n\t\t} else {\n\n\t\t\tai = index[ tri3 + 0 ] * stride + bufferOffset;\n\t\t\tbi = index[ tri3 + 1 ] * stride + bufferOffset;\n\t\t\tci = index[ tri3 + 2 ] * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\n\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n\nexport function buildTree( geo, options ) {\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geo );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partition( indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\t\t\tleft.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\t\t\tright.boundingData = new Float32Array( 6 );\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n\tensureIndex( geo, options );\n\n\t// Compute the full bounds of the geometry at the same time as triangle bounds because\n\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\n\t// We can't use the geometrying bounding box if it's available because it may be out of date.\n\tconst fullBounds = new Float32Array( 6 );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tconst triangleBounds = computeTriangleBounds( geo, fullBounds );\n\tconst indexArray = geo.index.array;\n\tconst maxDepth = options.maxDepth;\n\tconst verbose = options.verbose;\n\tconst maxLeafTris = options.maxLeafTris;\n\tconst strategy = options.strategy;\n\tconst onProgress = options.onProgress;\n\tconst totalTriangles = geo.index.count / 3;\n\tlet reachedMaxDepth = false;\n\n\tconst roots = [];\n\tconst ranges = getRootIndexRanges( geo );\n\n\tif ( ranges.length === 1 ) {\n\n\t\tconst range = ranges[ 0 ];\n\t\tconst root = new MeshBVHNode();\n\t\troot.boundingData = fullBounds;\n\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\n\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\troots.push( root );\n\n\t} else {\n\n\t\tfor ( let range of ranges ) {\n\n\t\t\tconst root = new MeshBVHNode();\n\t\t\troot.boundingData = new Float32Array( 6 );\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\n\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\n\t\t\troots.push( root );\n\n\t\t}\n\n\t}\n\n\treturn roots;\n\n}\n\nexport function buildPackedTree( geo, options ) {\n\n\t// boundingData  \t\t\t\t: 6 float32\n\t// right / offset \t\t\t\t: 1 uint32\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n\tconst roots = buildTree( geo, options );\n\n\tlet float32Array;\n\tlet uint32Array;\n\tlet uint16Array;\n\tconst packedRoots = [];\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\tfor ( let i = 0; i < roots.length; i ++ ) {\n\n\t\tconst root = roots[ i ];\n\t\tlet nodeCount = countNodes( root );\n\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tfloat32Array = new Float32Array( buffer );\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tpopulateBuffer( 0, root );\n\t\tpackedRoots.push( buffer );\n\n\t}\n\n\treturn packedRoots;\n\n\tfunction countNodes( node ) {\n\n\t\tif ( node.count ) {\n\n\t\t\treturn 1;\n\n\t\t} else {\n\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t\t}\n\n\t}\n\n\tfunction populateBuffer( byteOffset, node ) {\n\n\t\tconst stride4Offset = byteOffset / 4;\n\t\tconst stride2Offset = byteOffset / 2;\n\t\tconst isLeaf = ! ! node.count;\n\t\tconst boundingData = node.boundingData;\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t\t}\n\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t} else {\n\n\t\t\tconst left = node.left;\n\t\t\tconst right = node.right;\n\t\t\tconst splitAxis = node.splitAxis;\n\n\t\t\tlet nextUnusedPointer;\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\n\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t\t}\n\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\n\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\t\treturn nextUnusedPointer;\n\n\t\t}\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst v02 = new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = new Vector2();\n\tconst temp1 = new Vector3();\n\tconst temp2 = new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = new Vector3();\n\tconst projectedPointTemp = new Vector3();\n\tconst planeTemp = new Plane();\n\tconst lineTemp = new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n","import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst DIST_EPSILON = 1e-15;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < DIST_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.sphere = new Sphere();\n\t\tthis.plane = new Plane();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tthis.sphere.setFromPoints( this.points );\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\tconst edge = new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = new ExtendedTriangle();\n\tconst arr1 = new Array( 3 );\n\tconst arr2 = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst tempDir = new Vector3();\n\tconst edge = new Line3();\n\tconst edge1 = new Line3();\n\tconst edge2 = new Line3();\n\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\treturn function intersectsTriangle( other, target = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\tconst satBounds1 = this.satBounds;\n\t\t\tconst satAxes1 = this.satAxes;\n\t\t\tarr2[ 0 ] = other.a;\n\t\t\tarr2[ 1 ] = other.b;\n\t\t\tarr2[ 2 ] = other.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst satBounds2 = other.satBounds;\n\t\t\tconst satAxes2 = other.satAxes;\n\t\t\tarr1[ 0 ] = this.a;\n\t\t\tarr1[ 1 ] = this.b;\n\t\t\tarr1[ 2 ] = this.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( target ) {\n\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst points1 = this.points;\n\t\t\tlet found1 = false;\n\t\t\tlet count1 = 0;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst p = points1[ i ];\n\t\t\t\tconst pNext = points1[ ( i + 1 ) % 3 ];\n\n\t\t\t\tedge.start.copy( p );\n\t\t\t\tedge.end.copy( pNext );\n\t\t\t\tedge.delta( dir1 );\n\n\t\t\t\tconst targetPoint = found1 ? edge1.start : edge1.end;\n\t\t\t\tconst startIntersects = isNearZero( plane2.distanceToPoint( p ) );\n\t\t\t\tif ( isNearZero( plane2.normal.dot( dir1 ) ) && startIntersects ) {\n\n\t\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\t\tedge1.copy( edge );\n\t\t\t\t\tcount1 = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\t\tconst doesIntersect = plane2.intersectLine( edge, targetPoint ) || startIntersects;\n\t\t\t\tif ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {\n\n\t\t\t\t\tcount1 ++;\n\t\t\t\t\tif ( found1 ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfound1 = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find the other triangles edge that intersects this plane\n\t\t\tconst points2 = other.points;\n\t\t\tlet found2 = false;\n\t\t\tlet count2 = 0;\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst p = points2[ i ];\n\t\t\t\tconst pNext = points2[ ( i + 1 ) % 3 ];\n\n\t\t\t\tedge.start.copy( p );\n\t\t\t\tedge.end.copy( pNext );\n\t\t\t\tedge.delta( dir2 );\n\n\t\t\t\tconst targetPoint = found2 ? edge2.start : edge2.end;\n\t\t\t\tconst startIntersects = isNearZero( plane1.distanceToPoint( p ) );\n\t\t\t\tif ( isNearZero( plane1.normal.dot( dir2 ) ) && startIntersects ) {\n\n\t\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\t\tedge2.copy( edge );\n\t\t\t\t\tcount2 = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\t\tconst doesIntersect = plane1.intersectLine( edge, targetPoint ) || startIntersects;\n\t\t\t\tif ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {\n\n\t\t\t\t\tcount2 ++;\n\t\t\t\t\tif ( found2 ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfound2 = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\tedge1.delta( dir1 );\n\t\t\tedge2.delta( dir2 );\n\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\tlet tmp = edge2.start;\n\t\t\t\tedge2.start = edge2.end;\n\t\t\t\tedge2.end = tmp;\n\n\t\t\t}\n\n\t\t\t// check if the edges are overlapping\n\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\tconst separated1 = e1 < s2;\n\t\t\tconst separated2 = s1 < e2;\n\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// assign the target output\n\t\t\tif ( target ) {\n\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t}\n\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = new Vector3();\n\tconst point2 = new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = new Line3();\n\tconst line2 = new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new ExtendedTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst vA = /* @__PURE__ */ new Vector3();\nconst vB = /* @__PURE__ */ new Vector3();\nconst vC = /* @__PURE__ */ new Vector3();\n\nconst uvA = /* @__PURE__ */ new Vector2();\nconst uvB = /* @__PURE__ */ new Vector2();\nconst uvC = /* @__PURE__ */ new Vector2();\n\nconst intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, uv, a, b, c, side ) {\n\n\tvA.fromBufferAttribute( position, a );\n\tvB.fromBufferAttribute( position, b );\n\tvC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, vA, vB, vC, intersectionPoint, side );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\tuvA.fromBufferAttribute( uv, a );\n\t\t\tuvB.fromBufferAttribute( uv, b );\n\t\t\tuvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2( ) );\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( vA, vB, vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections ) {\n\n\tconst triOffset = tri * 3;\n\tconst a = geo.index.getX( triOffset );\n\tconst b = geo.index.getX( triOffset + 1 );\n\tconst c = geo.index.getX( triOffset + 2 );\n\n\tconst intersection = checkBufferGeometryIntersection( ray, geo.attributes.position, geo.attributes.uv, a, b, c, side );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n","\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i );\n\t\ti1 = index.getX( i + 1 );\n\t\ti2 = index.getX( i + 2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nexport function iterateOverTriangles(\n\toffset,\n\tcount,\n\tgeometry,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst index = geometry.index;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tsetTriangle( triangle, i * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, i, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getUV( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( ! target.uv ) target.uv = new Vector2();\n\t\ttarget.uv.copy( uv );\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv\n\t\t};\n\n\t}\n\n}\n","export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n","import { Box3, Vector3, Matrix4 } from 'three';\nimport { CONTAINED } from './Constants.js';\n\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { intersectTris, intersectClosestTri } from '../utils/GeometryRayIntersectUtilities.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX, SPLIT_AXIS } from './nodeBufferFunctions.js';\n\nconst boundingBox = new Box3();\nconst boxIntersection = new Vector3();\nconst xyzFields = [ 'x', 'y', 'z' ];\n\nexport function raycast( nodeIndex32, geometry, side, ray, intersects ) {\n\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris( geometry, side, ray, offset, count, intersects );\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, boxIntersection ) ) {\n\n\t\t\traycast( leftIndex, geometry, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, boxIntersection ) ) {\n\n\t\t\traycast( rightIndex, geometry, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport function raycastFirst( nodeIndex32, geometry, side, ray ) {\n\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\treturn intersectClosestTri( geometry, side, ray, offset, count );\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, boxIntersection );\n\t\tconst c1Result = c1Intersection ? raycastFirst( c1, geometry, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, boxIntersection );\n\t\tconst c2Result = c2Intersection ? raycastFirst( c2, geometry, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport const shapecast = ( function () {\n\n\tlet _box1, _box2;\n\tconst boxStack = [];\n\tconst boxPool = new PrimitivePool( () => new Box3() );\n\n\treturn function shapecast( ...args ) {\n\n\t\t_box1 = boxPool.getPrimitive();\n\t\t_box2 = boxPool.getPrimitive();\n\t\tboxStack.push( _box1, _box2 );\n\n\t\tconst result = shapecastTraverse( ...args );\n\n\t\tboxPool.releasePrimitive( _box1 );\n\t\tboxPool.releasePrimitive( _box2 );\n\t\tboxStack.pop();\n\t\tboxStack.pop();\n\n\t\tconst length = boxStack.length;\n\t\tif ( length > 0 ) {\n\n\t\t\t_box2 = boxStack[ length - 1 ];\n\t\t\t_box1 = boxStack[ length - 2 ];\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n\tfunction shapecastTraverse(\n\t\tnodeIndex32,\n\t\tgeometry,\n\t\tintersectsBoundsFunc,\n\t\tintersectsRangeFunc,\n\t\tnodeScoreFunc = null,\n\t\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\t\tdepth = 0\n\t) {\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t\t} else {\n\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tlet c1 = left;\n\t\t\tlet c2 = right;\n\n\t\t\tlet score1, score2;\n\t\t\tlet box1, box2;\n\t\t\tif ( nodeScoreFunc ) {\n\n\t\t\t\tbox1 = _box1;\n\t\t\t\tbox2 = _box2;\n\n\t\t\t\t// bounding data is not offset\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\t\tc1 = right;\n\t\t\t\t\tc2 = left;\n\n\t\t\t\t\tconst temp = score1;\n\t\t\t\t\tscore1 = score2;\n\t\t\t\t\tscore2 = temp;\n\n\t\t\t\t\tbox1 = box2;\n\t\t\t\t\t// box2 is always set before use below\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Check box 1 intersection\n\t\t\tif ( ! box1 ) {\n\n\t\t\t\tbox1 = _box1;\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t\t}\n\n\t\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\t\tlet c1StopTraversal;\n\t\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t\t} else {\n\n\t\t\t\tc1StopTraversal =\n\t\t\t\t\tc1Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc1,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c1StopTraversal ) return true;\n\n\t\t\t// Check box 2 intersection\n\t\t\t// cached box2 will have been overwritten by previous traversal\n\t\t\tbox2 = _box2;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\t\tlet c2StopTraversal;\n\t\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\t\tconst count = end - offset;\n\n\t\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t\t} else {\n\n\t\t\t\tc2StopTraversal =\n\t\t\t\t\tc2Intersection &&\n\t\t\t\t\tshapecastTraverse(\n\t\t\t\t\t\tc2,\n\t\t\t\t\t\tgeometry,\n\t\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\t\tdepth + 1\n\t\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( c2StopTraversal ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n} )();\n\nexport const intersectsGeometry = ( function () {\n\n\tconst triangle = new ExtendedTriangle();\n\tconst triangle2 = new ExtendedTriangle();\n\tconst invertedMat = new Matrix4();\n\n\tconst obb = new OrientedBox();\n\tconst obb2 = new OrientedBox();\n\n\treturn function intersectsGeometry( nodeIndex32, geometry, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\n\n\t\tif ( cachedObb === null ) {\n\n\t\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\t\totherGeometry.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\t\tcachedObb = obb;\n\n\t\t}\n\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\t\tif ( isLeaf ) {\n\n\t\t\tconst thisGeometry = geometry;\n\t\t\tconst thisIndex = thisGeometry.index;\n\t\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\t\tconst index = otherGeometry.index;\n\t\t\tconst pos = otherGeometry.attributes.position;\n\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t\t// here.\n\t\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn res;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {\n\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = nodeIndex32 + 8;\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\t\tconst leftIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t\tintersectsGeometry( left, geometry, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( leftIntersection ) return true;\n\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\t\tconst rightIntersection =\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t\tintersectsGeometry( right, geometry, otherGeometry, geometryToBvh, cachedObb );\n\n\t\t\tif ( rightIntersection ) return true;\n\n\t\t\treturn false;\n\n\t\t}\n\n\t};\n\n} )();\n\nfunction intersectRay( nodeIndex32, array, ray, target ) {\n\n\tarrayToBox( nodeIndex32, array, boundingBox );\n\treturn ray.intersectBox( boundingBox, target );\n\n}\n\nconst bufferStack = [];\nlet _prevBuffer;\nlet _float32Array;\nlet _uint16Array;\nlet _uint32Array;\nexport function setBuffer( buffer ) {\n\n\tif ( _prevBuffer ) {\n\n\t\tbufferStack.push( _prevBuffer );\n\n\t}\n\n\t_prevBuffer = buffer;\n\t_float32Array = new Float32Array( buffer );\n\t_uint16Array = new Uint16Array( buffer );\n\t_uint32Array = new Uint32Array( buffer );\n\n}\n\nexport function clearBuffer() {\n\n\t_prevBuffer = null;\n\t_float32Array = null;\n\t_uint16Array = null;\n\t_uint32Array = null;\n\n\tif ( bufferStack.length ) {\n\n\t\tsetBuffer( bufferStack.pop() );\n\n\t}\n\n}\n","import { intersectTri } from './ThreeRayIntersectUtilities.js';\n\nexport function intersectTris( geo, side, ray, offset, count, intersections ) {\n\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tintersectTri( geo, side, ray, i, intersections );\n\n\t}\n\n}\n\nexport function intersectClosestTri( geo, side, ray, offset, count ) {\n\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tconst intersection = intersectTri( geo, side, ray, i );\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\tif ( hit.distance < raycaster.near || hit.distance > raycaster.far ) {\n\n\t\treturn null;\n\n\t} else {\n\n\t\treturn hit;\n\n\t}\n\n}\n","import { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\nimport { buildPackedTree } from './buildFunctions.js';\nimport {\n\traycast,\n\traycastFirst,\n\tshapecast,\n\tintersectsGeometry,\n\tsetBuffer,\n\tclearBuffer,\n} from './castFunctions.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\n\nconst SKIP_GENERATION = Symbol( 'skip tree generation' );\n\nconst aabb = /* @__PURE__ */ new Box3();\nconst aabb2 = /* @__PURE__ */ new Box3();\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\nconst tempBox = /* @__PURE__ */ new Box3();\nconst trianglePool = /* @__PURE__ */ new PrimitivePool( () => new ExtendedTriangle() );\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\tif ( options.isBufferGeometry ) {\n\n\t\t\tconsole.warn( 'MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\treturn MeshBVH.serialize(\n\t\t\t\targuments[ 0 ],\n\t\t\t\t{\n\t\t\t\t\tcloneBuffers: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute.array.slice(),\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute.array,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\tif ( typeof options === 'boolean' ) {\n\n\t\t\tconsole.warn( 'MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.' );\n\n\t\t\treturn MeshBVH.deserialize(\n\t\t\t\targuments[ 0 ],\n\t\t\t\targuments[ 1 ],\n\t\t\t\t{\n\t\t\t\t\tsetIndex: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\tstrategy: CENTER,\n\t\t\tmaxDepth: 40,\n\t\t\tmaxLeafTris: 10,\n\t\t\tverbose: true,\n\t\t\tuseSharedArrayBuffer: false,\n\t\t\tsetBoundingBox: true,\n\t\t\tonProgress: null,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined' ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\tthis._roots = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tthis._roots = buildPackedTree( geometry, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\t\tnodeIndices = new Set( nodeIndices );\n\n\t\t}\n\n\t\tconst geometry = this.geometry;\n\t\tconst indexArr = geometry.index.array;\n\t\tconst posAttr = geometry.attributes.position;\n\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tbuffer = roots[ i ];\n\t\t\tuint32Array = new Uint32Array( buffer );\n\t\t\tuint16Array = new Uint16Array( buffer );\n\t\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t\t_traverse( 0, byteOffset );\n\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t}\n\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\t\tlet minx = Infinity;\n\t\t\t\tlet miny = Infinity;\n\t\t\t\tlet minz = Infinity;\n\t\t\t\tlet maxx = - Infinity;\n\t\t\t\tlet maxy = - Infinity;\n\t\t\t\tlet maxz = - Infinity;\n\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\t\tconst index = indexArr[ i ];\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t\t) {\n\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst left = node32Index + 8;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\t\tconst offsetRight = right + byteOffset;\n\t\t\t\tlet forceChildren = force;\n\t\t\t\tlet includesLeft = false;\n\t\t\t\tlet includesRight = false;\n\n\t\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tincludesLeft = true;\n\t\t\t\t\tincludesRight = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\t\tlet leftChange = false;\n\t\t\t\tif ( traverseLeft ) {\n\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tlet rightChange = false;\n\t\t\t\tif ( traverseRight ) {\n\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t\t}\n\n\t\t\t\tconst didChange = leftChange || rightChange;\n\t\t\t\tif ( didChange ) {\n\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn didChange;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\tsetBuffer( roots[ i ] );\n\t\t\traycast( 0, geometry, materialSide, ray, intersects );\n\t\t\tclearBuffer();\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\n\t\t\tsetBuffer( roots[ i ] );\n\t\t\tconst result = raycastFirst( 0, geometry, materialSide, ray );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tconst geometry = this.geometry;\n\t\tlet result = false;\n\t\tfor ( const root of this._roots ) {\n\n\t\t\tsetBuffer( root );\n\t\t\tresult = intersectsGeometry( 0, geometry, otherGeometry, geomToMesh );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\n\n\t\tconst geometry = this.geometry;\n\t\tif ( callbacks instanceof Function ) {\n\n\t\t\tif ( _intersectsTriangleFunc ) {\n\n\t\t\t\t// Support the previous function signature that provided three sequential index buffer\n\t\t\t\t// indices here.\n\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\n\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\n\n\t\t\t\t\tconst i3 = index * 3;\n\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\n\n\t\t\t\t};\n\n\n\t\t\t}\n\n\t\t\tcallbacks = {\n\n\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\n\t\t\t\tintersectsBounds: callbacks,\n\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\n\t\t\t\tintersectsRange: null,\n\n\t\t\t};\n\n\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\n\n\t\t}\n\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tfor ( const root of this._roots ) {\n\n\t\t\tsetBuffer( root );\n\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\t\t\tclearBuffer();\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n\t\t// than an approach that walks down the tree (see bvhcast.js file for more info).\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst indexAttr = this.geometry.index;\n\t\tconst positionAttr = this.geometry.attributes.position;\n\n\t\tconst otherIndexAttr = otherBvh.geometry.index;\n\t\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\n\n\t\ttempMatrix.copy( matrixToLocal ).invert();\n\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tfunction iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle, i1 * 3, indexAttr, positionAttr );\n\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\totherBvh.getBoundingBox( aabb2 );\n\t\taabb2.applyMatrix4( matrixToLocal );\n\t\tconst result = this.shapecast( {\n\n\t\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\n\n\t\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\n\n\t\t\t\taabb.copy( box );\n\t\t\t\taabb.applyMatrix4( tempMatrix );\n\t\t\t\treturn otherBvh.shapecast( {\n\n\t\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\n\n\t\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\n\n\t\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\n\n\t\t\t\t\t},\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\t\ttrianglePool.releasePrimitive( triangle2 );\n\t\treturn result;\n\n\t}\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tobb.needsUpdate = true;\n\n\t\tconst geometry = this.geometry;\n\t\tconst pos = geometry.attributes.position;\n\t\tconst index = geometry.index;\n\t\tconst otherPos = otherGeometry.attributes.position;\n\t\tconst otherIndex = otherGeometry.index;\n\t\tconst triangle = trianglePool.getPrimitive();\n\t\tconst triangle2 = trianglePool.getPrimitive();\n\n\t\tlet tempTarget1 = temp1;\n\t\tlet tempTargetDest1 = temp2;\n\t\tlet tempTarget2 = null;\n\t\tlet tempTargetDest2 = null;\n\n\t\tif ( target2 ) {\n\n\t\t\ttempTarget2 = temp3;\n\t\t\ttempTargetDest2 = temp4;\n\n\t\t}\n\n\t\tlet closestDistance = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tlet closestDistanceOtherTriIndex = null;\n\t\ttempMatrix.copy( geometryToBvh ).invert();\n\t\tobb2.matrix.copy( tempMatrix );\n\t\tthis.shapecast(\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast( {\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\ttrianglePool.releasePrimitive( triangle );\n\t\ttrianglePool.releasePrimitive( triangle2 );\n\n\t\tif ( closestDistance === Infinity ) return null;\n\n\t\tif ( ! target1.point ) target1.point = tempTargetDest1.clone();\n\t\telse target1.point.copy( tempTargetDest1 );\n\t\ttarget1.distance = closestDistance,\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\t\tif ( target2 ) {\n\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\t\telse target2.point.copy( tempTargetDest2 );\n\t\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t\t}\n\n\t\treturn target1;\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\t// early out if under minThreshold\n\t\t// skip checking if over maxThreshold\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t\t// returns Infinity if no value found\n\t\tconst minThresholdSq = minThreshold * minThreshold;\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\t\tlet closestDistanceSq = Infinity;\n\t\tlet closestDistanceTriIndex = null;\n\t\tthis.shapecast(\n\n\t\t\t{\n\n\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t\t},\n\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t\t},\n\n\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t}\n\n\t\t);\n\n\t\tif ( closestDistanceSq === Infinity ) return null;\n\n\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\t\tif ( ! target.point ) target.point = temp1.clone();\n\t\telse target.point.copy( temp1 );\n\t\ttarget.distance = closestDistance,\n\t\ttarget.faceIndex = closestDistanceTriIndex;\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n","export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n"],"names":["CENTER","AVERAGE","SAH","CONTAINED","TRIANGLE_INTERSECT_COST","TRAVERSAL_COST","BYTES_PER_NODE","IS_LEAFNODE_FLAG","FLOAT32_EPSILON","Math","pow","MeshBVHNode","constructor","arrayToBox","nodeIndex32","array","target","min","x","y","z","max","getLongestEdgeIndex","bounds","splitDimIdx","splitDist","i","dist","copyBounds","source","set","unionBounds","a","b","aVal","bVal","d","d3","expandByTriangleBounds","startIndex","triangleBounds","tCenter","tHalf","tMin","tMax","computeSurfaceArea","d0","d1","d2","getBounds","offset","count","centroidTarget","minx","Infinity","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","includeCentroid","end","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","binsSort","candidate","sahBins","Array","fill","map","Float32Array","rightCacheBounds","leftCacheBounds","leftBounds","SeparatingAxisBounds","this","setFromPointsField","points","field","l","length","val","setFromPoints","axis","p","dot","isSeparated","other","prototype","setFromBox","box","boxMin","boxMax","closestPointLineToLine","dir1","dir2","v02","l1","l2","result","v0","start","v10","v2","v32","subVectors","d0232","d3210","d3232","d0210","denom","closestPointsSegmentToSegment","paramResult","temp1","temp2","target1","target2","at","closestPointToPoint","p2","closestPoint","closestPoint2","distanceToSquared","copy","sphereIntersectTriangle","closestPointTemp","projectedPointTemp","planeTemp","lineTemp","sphere","triangle","radius","center","c","distanceTo","plane","getPlane","abs","distanceToPoint","pp","projectPoint","containsPoint","isNearZero","value","ExtendedTriangle","args","super","isExtendedTriangle","satAxes","satBounds","needsUpdate","intersectsSphere","update","axis0","sab0","getNormal","axis1","sab1","axis2","sab2","axis3","sab3","setFromNormalAndCoplanarPoint","closestPointToSegment","point1","point2","edge","segment","distSq","closestDistanceSq","nexti","sqrt","intersectsTriangle","saTri2","arr1","arr2","cachedSatBounds","cachedSatBounds2","cachedAxis","tempDir","edge1","edge2","plane1","plane2","normal","satBounds1","satAxes1","sb","sa","satBounds2","satAxes2","sa1","i2","sa2","crossVectors","console","warn","points1","found1","count1","pNext","delta","targetPoint","startIntersects","intersectLine","points2","found2","count2","tmp","s1","e1","s2","e2","separated1","separated2","point","distanceToTriangle","cornerFields","line1","line2","lineTarget","getCenter","otherVec","thisVec","f11","f12","f21","f22","OrientedBox","matrix","isOrientedBox","invMatrix","alignedSatBounds","v","applyMatrix4","minVec","pi","invert","intersectsBox","aabbBounds","saTri","pointsArr","triSatBounds","triSatAxes","clamp","distanceToBox","xyzFields","segments1","segments2","threshold","threshold2","i1","nextIndex","nextIndex2","index2","p1","f1","f2","f3","vA","vB","vC","uvA","uvB","uvC","intersectionPoint","intersectTri","geo","side","ray","tri","intersections","triOffset","index","getX","intersection","position","uv","fromBufferAttribute","pA","pB","pC","intersect","intersectTriangle","distance","origin","clone","checkIntersection","face","materialIndex","faceIndex","checkBufferGeometryIntersection","attributes","push","setTriangle","pos","ta","tb","tc","i0","getY","getZ","iterateOverTriangles","geometry","intersectsTriangleFunc","contained","depth","PrimitivePool","getNewPrimitive","_getNewPrimitive","_primitives","getPrimitive","primitives","pop","releasePrimitive","primitive","boundingBox","boxIntersection","raycast","intersects","nodeIndex16","float32Array","_float32Array","uint16Array","_uint16Array","uint32Array","_uint32Array","intersectTris","leftIndex","intersectRay","rightIndex","raycastFirst","res","intersectClosestTri","splitAxis","xyzAxis","leftToRight","direction","c1","c2","c1Result","c2Result","shapecast","_box1","_box2","boxStack","boxPool","shapecastTraverse","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","getLeftOffset","getRightEndOffset","left","right","score1","score2","box1","box2","temp","c1Intersection","c1StopTraversal","c2Intersection","c2StopTraversal","intersectsGeometry","triangle2","invertedMat","obb","obb2","otherGeometry","geometryToBvh","cachedObb","computeBoundingBox","thisGeometry","thisIndex","thisPos","boundsTree","intersectsBounds","intersectBox","bufferStack","_prevBuffer","setBuffer","buffer","Uint16Array","Uint32Array","clearBuffer","SKIP_GENERATION","Symbol","aabb","aabb2","tempMatrix","temp3","temp4","tempBox","trianglePool","MeshBVH","static","bvh","options","isBufferGeometry","serialize","arguments","cloneBuffers","undefined","rootData","_roots","indexAttribute","getIndex","roots","root","slice","data","deserialize","setIndex","newIndex","Error","isInterleavedBufferAttribute","Object","assign","strategy","maxDepth","maxLeafTris","verbose","useSharedArrayBuffer","setBoundingBox","onProgress","SharedArrayBuffer","triggerProgress","trianglesProcessed","totalTriangles","splitNode","node","centroidBoundingData","reachedMaxDepth","split","nodeBoundingData","avg","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","binWidth","BIN_COUNT","truncatedBins","bin","sort","splitCount","bi","splice","leftCount","rightCount","rightBounds","leftProb","rightProb","cost","binIndex","lastBin","nextBin","binCount","getOptimalSplit","boundingData","splitOffset","axisOffset","t0","t1","t2","partition","indexArray","lstart","lcount","cacheCentroidBoundingData","rstart","rcount","vertexCount","BufferConstructor","ArrayBuffer","ensureIndex","fullBounds","posAttr","triCount","normalized","posArr","bufferOffset","stride","getters","tri3","tri6","ai","ci","el","halfExtents","el2","computeTriangleBounds","ranges","groups","rangeBoundaries","Set","group","add","sortedBoundaries","from","values","getRootIndexRanges","range","getCentroidBounds","buildTree","packedRoots","nodeCount","countNodes","populateBuffer","byteOffset","stride4Offset","stride2Offset","isLeaf","nextUnusedPointer","buildPackedTree","getBoundingBox","refit","nodeIndices","isArray","indexArr","_traverse","byteLength","node32Index","force","node16Index","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","traverse","callback","rootIndex","materialOrSide","isMaterial","isArrayMaterial","materialSide","startCount","j","jl","closestResult","geomToMesh","callbacks","_intersectsTriangleFunc","_orderNodesFunc","Function","originalTriangleFunc","i3","boundsTraverseOrder","intersectsRange","originalIntersectsRange","nodeIndex","bvhcast","otherBvh","matrixToLocal","intersectsRanges","intersectsTriangles","indexAttr","positionAttr","otherIndexAttr","otherPositionAttr","iterateOverDoubleTriangles","offset1","offset2","depth1","index1","depth2","originalIntersectsRanges","nodeIndex1","nodeIndex2","boxToMesh","closestPointToGeometry","minThreshold","maxThreshold","otherPos","otherIndex","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistance","closestDistanceTriIndex","closestDistanceOtherTriIndex","score","otherOffset","otherCount","sub","minThresholdSq","maxThresholdSq","triIndex","makeEmpty","forEach","union","IS_LEAF","n16","OFFSET","n32","COUNT","LEFT_NODE","RIGHT_NODE","SPLIT_AXIS","BOUNDING_DATA_INDEX"],"sourceRoot":""}